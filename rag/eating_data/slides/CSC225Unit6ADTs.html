---
{
  "doc_type": "slides",
  "source": "/home/isaak/projects/course-to-md/CSC225/Slides/CSC225Unit6ADTs.pdf",
  "pages": 54,
  "avg_landscape": true,
  "words_est_first2pages": 134,
  "hash": "3dae8b15652d867f"
}
---

<span id="1"></span>

<div id="page1-div" style="position:relative;width:1440px;height:810px;">

Unit 06: Abstract Data Types   
(ADTs)

Anthony Estey

CSC 115: Fundamentals of Programming II

University of Victoria

</div>

<span id="2"></span>

<div id="page2-div" style="position:relative;width:1440px;height:810px;">

Data Structures



A data structure is a container used to store data (objects).



Typically, this is done in one of two ways:



Contiguous-based structure



Node-based structure



Although their implementations are different, both data structures can   
store the same data, and perform the same operations on that data



For example: add and remove students from a course’s waitlist



There are tradeoffs associated with each implementation:



Arrays allow immediate access to the 

𝑖

th element in collection (

0 ≤ 𝑖 \< 𝑛

)



A linked-list requires iteration from one end of the list to reach the 

𝑖

th position

3

CSC 225: Algorithms and Data Structures I -- Anthony Estey

Array

Linked List

</div>

<span id="3"></span>

<div id="page3-div" style="position:relative;width:1440px;height:810px;">

Abstract Data Types (ADTs)



An ADT is composed of:



A description of what data is stored 



A set of operations on that data



The separation of what something does (specification) and how it does   
it (implementation) is a fundamental concept in engineering\!

4

CSC 225: Algorithms and Data Structures I -- Anthony Estey

(but not how the data is stored)

(but not how the operations are implemented)

</div>

<span id="4"></span>

<div id="page4-div" style="position:relative;width:1440px;height:810px;">

Why the split?



Think about it from a software development perspective:



When we have specifications without implementation details:



This is the perfect medium for which clients and developers can communicate



Clients can request behaviours, developers can discuss these requests, until an   
agreement is made



Clients are not programmers, they are not interested in implementation   
details, but they are interested in *what *the program can do



Developers then provide an implementation based on the specification (the   
clients *use *the end product, but don’t ever have to see the underlying code)

5

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="5"></span>

<div id="page5-div" style="position:relative;width:1440px;height:810px;">

Example



ADT Dictionary:



***What***

data is stored, and what operations must it perform?



Stores a pair of strings, representing the word and definition (data)



Operations:



insert(word, definition)



find(word)



delete(word)



We use a data structure to implement an ADT



this is where the

***how***

comes in

6

CSC 225: Algorithms and Data Structures I -- Anthony Estey

We also know the effect operations have   
on the data.   
If we 

***delete***

a word from the dictionary, 

a subsequent 

***find***

operation should fail. 

</div>

<span id="6"></span>

<div id="page6-div" style="position:relative;width:1440px;height:810px;">

Implementing the Dictionary ADT

7

CSC 225: Algorithms and Data Structures I -- Anthony Estey

insert

delete

find

…

Data structure

Program

(client view)

requests to 

perform operation 

Dictionary ADT

Operations

result of 

operation

Interface

Array

</div>

<span id="7"></span>

<div id="page7-div" style="position:relative;width:1440px;height:810px;">

Client vs Programmer



Clients know how to use something



***What***

operations are available and 

***what***

they do



Programmers must decide 

***how ***

to implement the operations



Their choices may be influenced by a number of things:



execution speed



memory requirements 



maintenance (debugging, scalability, etc.)



Dictionary example:



Clients/users: add new words to dictionary, look up words to see definitions



Programmer: determine 

***how***

data is stored; 

***how***

operations are implemented

8

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="8"></span>

<div id="page8-div" style="position:relative;width:1440px;height:810px;">

The Notion of a Stack



Collection of items



Items are returned in the 

***reverse***

order they were added



This is behavior is often abbreviated LIFO (Last In, First Out)

9

CSC 225: Algorithms and Data Structures I -- Anthony Estey

Programming

Algorithms

DataBases

Operating Systems

Software Engineering

</div>

<span id="9"></span>

<div id="page9-div" style="position:relative;width:1440px;height:810px;">

The Stack ADT



The Stack ADT specifies the following operations:



push(*o*): Insert object *o *onto the top of the stack



pop(): Access and remove the object from the top of the stack; an error occurs   
if the stack is empty



isEmpty(): Determines whether the stack is currently empty



top(): Accesses the object on top of the stack without removing it; an error   
occurs if the stack is empty



size(): Gets the current number of objects in the stack

10

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="10"></span>

<div id="page10-div" style="position:relative;width:1440px;height:810px;">

Stack Examples



Things we use all the time: 



“Undo” function found in most applications



Back button when browsing the web



Programming:



The runtime environment’s handling of nested method calls



Recursion



Problem solving:



Approaches where a problem is solved by breaking the problem up into smaller   
version of the same problem. (Divide-and-conquer)

11

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="11"></span>

<div id="page11-div" style="position:relative;width:1440px;height:810px;">



A stack can be implemented in multiple ways:



In an array implementation, we typically have the following:



𝐴

: an 

𝑛

\-element array



𝑡

: an integer to keep track of the index of the top element in the array



Example:

5

4

3

2

1

0

Stack Implementation

12

CSC 225: Algorithms and Data Structures I -- Anthony Estey

A

t 2

</div>

<span id="12"></span>

<div id="page12-div" style="position:relative;width:1440px;height:810px;">



A stack can be implemented in multiple ways:



In an array implementation, we typically have the following:



𝐴

: an 

𝑛

\-element array



𝑡

: an integer to keep track of the index of the top element in the array



Example:



**push(**

***o***

**)**

5

4

3

2

1

0

Stack Implementation

13

CSC 225: Algorithms and Data Structures I -- Anthony Estey

A

t 2

*o*

**3**

</div>

<span id="13"></span>

<div id="page13-div" style="position:relative;width:1440px;height:810px;">

3

**2**



A stack can be implemented in multiple ways:



In an array implementation, we typically have the following:



𝐴

: an 

𝑛

\-element array



𝑡

: an integer to keep track of the index of the top element in the array



Example:



push(o)



**pop()**

5

4

3

2

1

0

Stack Implementation

14

CSC 225: Algorithms and Data Structures I -- Anthony Estey

A

t

*o*

</div>

<span id="14"></span>

<div id="page14-div" style="position:relative;width:1440px;height:810px;">

The Notion of a Queue



Collection of items



Items are returned in the 

***same***

order they were added



This is behavior is often abbreviated FIFO (First In, First Out)

15

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="15"></span>

<div id="page15-div" style="position:relative;width:1440px;height:810px;">

The Queue ADT



The Queue ADT specifies the following operations:



enqueue(*o*): Insert object *o *at the rear (back) of the queue



dequeue(): Access and remove the object from the front of the queue; an error   
occurs if the queue is empty



isEmpty(): Determines whether the queue is currently empty



front(): Accesses the object at the front of the queue without removing it; an   
error occurs if the queue is empty



size(): Gets the current number of objects in the queue

16

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="16"></span>

<div id="page16-div" style="position:relative;width:1440px;height:810px;">

Queue Examples



Any time people wait in line for something 



the bank, the cafeteria, etc.



Waitlists for classes here at Uvic\!

17

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="17"></span>

<div id="page17-div" style="position:relative;width:1440px;height:810px;">



We will explore an array-based implementation of a queue during   
lecture

Queue Implementation

18

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="18"></span>

<div id="page18-div" style="position:relative;width:1440px;height:810px;">

Queue implementation with a circular array

19

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Algorithm **enqueue(

𝑜𝑏𝑗

):

**if **isFull() **then**

**return **an error (queue is full)

𝐴 𝑏 ← 𝑜𝑏𝑗  
𝑏 ← (𝑏 + 1)

mod 

𝑁

**Algorithm **dequeue():

**if **isEmpty() **then**

**return **an error (queue is empty)

𝑒 ← 𝐴 𝑓  
𝑓 ← (𝑓 + 1)

mod 

𝑁

**return**

𝑒

0

1

2

3

4

f

b

</div>

<span id="19"></span>

<div id="page19-div" style="position:relative;width:1440px;height:810px;">

3

Queue implementation with a circular array

20

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Algorithm **enqueue(

𝑜𝑏𝑗

):

**if **isFull() **then**

**return **an error (queue is full)

𝐴 𝑏 ← 𝑜𝑏𝑗  
𝑏 ← (𝑏 + 1)

mod 

𝑁

**Algorithm **dequeue():

**if **isEmpty() **then**

**return **an error (queue is empty)

𝑒 ← 𝐴 𝑓  
𝑓 ← (𝑓 + 1)

mod 

𝑁

**return**

𝑒

0

1

2

3

4

f

b

enqueue(3);

</div>

<span id="20"></span>

<div id="page20-div" style="position:relative;width:1440px;height:810px;">

33

5

Queue implementation with a circular array

21

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Algorithm **enqueue(

𝑜𝑏𝑗

):

**if **isFull() **then**

**return **an error (queue is full)

𝐴 𝑏 ← 𝑜𝑏𝑗  
𝑏 ← (𝑏 + 1)

mod 

𝑁

**Algorithm **dequeue():

**if **isEmpty() **then**

**return **an error (queue is empty)

𝑒 ← 𝐴 𝑓  
𝑓 ← (𝑓 + 1)

mod 

𝑁

**return**

𝑒

0

1

2

3

4

f

enqueue(3);

enqueue(5);

b

</div>

<span id="21"></span>

<div id="page21-div" style="position:relative;width:1440px;height:810px;">

3

5

3

5

b

Queue implementation with a circular array

22

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Algorithm **enqueue(

𝑜𝑏𝑗

):

**if **isFull() **then**

**return **an error (queue is full)

𝐴 𝑏 ← 𝑜𝑏𝑗  
𝑏 ← (𝑏 + 1)

mod 

𝑁

**Algorithm **dequeue():

**if **isEmpty() **then**

**return **an error (queue is empty)

𝑒 ← 𝐴 𝑓  
𝑓 ← (𝑓 + 1)

mod 

𝑁

**return**

𝑒

0

1

2

3

4

f

enqueue(3);  
enqueue(5);

dequeue();

</div>

<span id="22"></span>

<div id="page22-div" style="position:relative;width:1440px;height:810px;">

3

5

3

5

b

Queue implementation with a circular array

23

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Algorithm **enqueue(

𝑜𝑏𝑗

):

**if **isFull() **then**

**return **an error (queue is full)

𝐴 𝑏 ← 𝑜𝑏𝑗  
𝑏 ← (𝑏 + 1)

mod 

𝑁

**Algorithm **dequeue():

**if **isEmpty() **then**

**return **an error (queue is empty)

𝑒 ← 𝐴 𝑓  
𝑓 ← (𝑓 + 1)

mod 

𝑁

**return**

𝑒

0

1

2

3

4

enqueue(3);  
enqueue(5);  
dequeue();

f

dequeue();

</div>

<span id="23"></span>

<div id="page23-div" style="position:relative;width:1440px;height:810px;">

3

5

3

5

b

Queue implementation with a circular array

24

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Algorithm **enqueue(

𝑜𝑏𝑗

):

**if **isFull() **then**

**return **an error (queue is full)

𝐴 𝑏 ← 𝑜𝑏𝑗  
𝑏 ← (𝑏 + 1)

mod 

𝑁

**Algorithm **dequeue():

**if **isEmpty() **then**

**return **an error (queue is empty)

𝑒 ← 𝐴 𝑓  
𝑓 ← (𝑓 + 1)

mod 

𝑁

**return**

𝑒

0

1

2

3

4

enqueue(3);  
enqueue(5);  
dequeue();

f

dequeue();

</div>

<span id="24"></span>

<div id="page24-div" style="position:relative;width:1440px;height:810px;">

3

5

3

5

b

Queue implementation with a circular array

25

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Algorithm **enqueue(

𝑜𝑏𝑗

):

**if **isFull() **then**

**return **an error (queue is full)

𝐴 𝑏 ← 𝑜𝑏𝑗  
𝑏 ← (𝑏 + 1)

mod 

𝑁

**Algorithm **dequeue():

**if **isEmpty() **then**

**return **an error (queue is empty)

𝑒 ← 𝐴 𝑓  
𝑓 ← (𝑓 + 1)

mod 

𝑁

**return**

𝑒

0

1

2

3

4

enqueue(3);  
enqueue(5);  
dequeue();

f

dequeue();

enqueue(7);  
enqueue(2);  
enqueue(1);  
enqueue(4);  
enqueue(5);

3

5

7

3

5

7

2

3

5

7

2

1

4

5

7

2

1

4

5

7

2

1

</div>

<span id="25"></span>

<div id="page25-div" style="position:relative;width:1440px;height:810px;">

3

5

4

5

7

2

1

b

Queue implementation with a circular array

26

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Algorithm **enqueue(

𝑜𝑏𝑗

):

**if **isFull() **then**

**return **an error (queue is full)

𝐴 𝑏 ← 𝑜𝑏𝑗  
𝑏 ← (𝑏 + 1)

mod 

𝑁

**Algorithm **dequeue():

**if **isEmpty() **then**

**return **an error (queue is empty)

𝑒 ← 𝐴 𝑓  
𝑓 ← (𝑓 + 1)

mod 

𝑁

**return**

𝑒

0

1

2

3

4

f

enqueue(3);  
enqueue(5);  
dequeue();  
dequeue();  
enqueue(7);  
enqueue(2);  
enqueue(1);  
enqueue(4);  
enqueue(5);

</div>

<span id="26"></span>

<div id="page26-div" style="position:relative;width:1440px;height:810px;">

**Algorithm **dequeue():

**if **isEmpty() **then**

**return **an error (queue is empty)

𝑒 ← 𝐴 𝑓  
𝑓 ← (𝑓 + 1)

mod 

𝑁

𝑐𝑜𝑢𝑛𝑡 ← 𝑐𝑜𝑢𝑛𝑡 − 1

**return**

𝑒

**Algorithm **enqueue(

𝑜𝑏𝑗

):

**if **isFull() **then**

**return **an error (queue is full)

𝐴 𝑏 ← 𝑜𝑏𝑗  
𝑏 ← (𝑏 + 1)

mod 

𝑁

𝑐𝑜𝑢𝑛𝑡 ← 𝑐𝑜𝑢𝑛𝑡 + 1

3

5

4

5

7

2

1

b

Queue implementation with a circular array

27

CSC 225: Algorithms and Data Structures I -- Anthony Estey

0

1

2

3

4

f

enqueue(3);  
enqueue(5);  
dequeue();  
dequeue();  
enqueue(7);  
enqueue(2);  
enqueue(1);  
enqueue(4);  
enqueue(5);

**Algorithm **isFull():

**return**

𝑐𝑜𝑢𝑛𝑡 = 𝑁

**Algorithm **isEmpty():

**return**

𝑐𝑜𝑢𝑛𝑡 = 0

Method 1: Use a count variable

Pros:

\- simplicity. Both isFull and isEmpty

are easy to implement

Cons:

\- Memory (allocated another variable)  
\- additional operations to update the   

variable every enqueue and dequeue

</div>

<span id="27"></span>

<div id="page27-div" style="position:relative;width:1440px;height:810px;">

4

5

7

2

1

4

7

2

1

**Algorithm **dequeue():

**if **isEmpty() **then**

**return **an error (queue is empty)

𝑒 ← 𝐴 𝑓  
𝑓 ← (𝑓 + 1)

mod 

𝑁

**return**

𝑒

**Algorithm **enqueue(

𝑜𝑏𝑗

):

**if **isFull() **then**

**return **an error (queue is full)

𝐴 𝑏 ← 𝑜𝑏𝑗  
𝑏 ← (𝑏 + 1)

mod 

𝑁

b

Queue implementation with a circular array

28

CSC 225: Algorithms and Data Structures I -- Anthony Estey

0

1

2

3

4

f

enqueue(3);  
enqueue(5);  
dequeue();  
dequeue();  
enqueue(7);  
enqueue(2);  
enqueue(1);  
enqueue(4);  
enqueue(5);

**Algorithm **isFull():

**return**

𝑏 + 1

mod 

𝑁 = 𝑓

**Algorithm **isEmpty():

**return**

𝑓 = 𝑏

Method 2: Full when 

𝑠𝑖𝑧𝑒 = 𝑁 − 1

Pros:

\- Speed. Fewest operations required

Cons:

\- Array memory is never fully utilized    

(always at least 1 unused spot)

4

5

7

2

1

3

5

2

6

b

0

1

2

3

4

f

</div>

<span id="28"></span>

<div id="page28-div" style="position:relative;width:1440px;height:810px;">

**Algorithm **dequeue():

**if **isEmpty() **then**

**return **an error (queue is empty)

𝑒 ← 𝐴 𝑓  
𝑓 ← (𝑓 + 1)

mod 

𝑁

**if **

𝑓 = 𝑏

**then**

𝑓 ← −1

**return**

𝑒

\-1

0

1

2

3

4

**Algorithm **enqueue(

𝑜𝑏𝑗

):

**if **isFull() **then**

**return **an error (queue is full)

**else if **isEmpty() **then**

𝑓 ← 0  
𝑏 ← 0

𝐴 𝑏 ← 𝑜𝑏𝑗  
𝑏 ← (𝑏 + 1)

mod 

𝑁

3

5

b

Queue implementation with a circular array

29

CSC 225: Algorithms and Data Structures I -- Anthony Estey

f

enqueue(3);  
enqueue(8);  
enqueue(2);  
dequeue();  
enqueue(5);

**Algorithm **isFull():

**return**

𝑓 = 𝑏

**Algorithm **isEmpty():

**return**

𝑓 = −1

Method 3: 

𝑓, 𝑏 = −1

when empty

Pros:

\- Relatively efficient (only re-assign 

𝑓

or 

𝑏

when the queue is full or empty)

\- Array memory fully utilized

Cons:

\- Additional conditional operations on   

every enqueue and dequeue

enqueue(4);  
enqueue(9);

33

8

3

8

2

3

8

2

3

8

2

5

3

8

2

5

4

9

8

2

5

4

</div>

<span id="29"></span>

<div id="page29-div" style="position:relative;width:1440px;height:810px;">

The Notion of a List



Collection of items



Elements can be inserted and removed in 

***any***

order



Any element can be accessed at any given time by their position in the list



Not just the front (Queue) or top (Stack) element

30

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="30"></span>

<div id="page30-div" style="position:relative;width:1440px;height:810px;">

Index-Based Lists



We can uniquely refer to each element in the list containing 

𝑛

elements using an integer in the range 

\[0, 𝑛 − 1\]



We define the **index **or **rank **of an element 

𝑒

in a list by the number of 

elements that come before 

𝑒

in the list



Hence the first element is at index 

0

, and the last element is at index 

𝑛 − 1



Index-based lists support the following operations:



**get(**

***r***

**): **Return the element in the list with index 

𝑟

.



**set(**

***r, e***

**): **Replace element at index 

𝑟

with 

𝑒

and return the element replaced.



**add(**

***r, e***

**): **Insert a new element 

𝑒

into the list at index 

𝑟

.



**remove(**

***r***

**): **Remove the element at index 

𝑟

from the list.

31

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="31"></span>

<div id="page31-div" style="position:relative;width:1440px;height:810px;">

Array Implementation of a List



The **get(**

***r***

**) **and **set(**

***r, e***

**) **operations can be done in 

𝑶(𝟏)

time:



**get(3)**



**set(5, 12)**

32

CSC 225: Algorithms and Data Structures I -- Anthony Estey

2

3

5

7

9

13

14

16

20

22

0

1

2

3

4

5

6

7

8

9

returns 7  
returns 13

12

12

</div>

<span id="32"></span>

<div id="page32-div" style="position:relative;width:1440px;height:810px;">

Lists – Array Implementation



**add(**

***r, e***

**) **cannot be done in 

𝑂(1)

time



**add(**

***3, 6***

**):**

33

CSC 225: Algorithms and Data Structures I -- Anthony Estey

2

3

5

7

9

13

14

16

20

0

1

2

3

4

5

6

7

8

9

20

14

13

9

7

16

6

6

On average, half of the elements   
need to be shuffled:      

𝑂(𝑛)

**Algorithm **add(

𝑟, 𝑒

):

**if**

𝑛 = 𝑁

**then**

**return error **(List is full)

**if**

𝑟 \< 𝑛

**then**

**for**

𝑖 ← 𝑛 − 1

to 

𝑟

**do**

𝐴\[𝑖 + 1\] ← 𝐴\[𝑖\]

𝐴\[𝑟\] ← 𝑒  
𝑛 ← 𝑛 + 1

</div>

<span id="33"></span>

<div id="page33-div" style="position:relative;width:1440px;height:810px;">

Lists – Array Implementation



**remove(**

***r***

**) **has the same problem



**remove(**

***6***

**):**

34

CSC 225: Algorithms and Data Structures I -- Anthony Estey

2

3

5

6

9

13

14

16

20

0

1

2

3

4

5

6

7

8

9

20

14

13

9

7

16

13

**Algorithm **remove(

𝑟

):

**if**

𝑟 \< 𝑛 − 1

**then**

𝑒 ← 𝐴\[𝑟\]

**for**

𝑖 ← 𝑟

to 

𝑛 − 2

**do**

𝐴 𝑖 ← 𝐴 𝑖 + 1

𝑛 ← 𝑛 + 1

**return**

𝑒

Runtime of **remove(**

***r***

**)**:  

𝑂(𝑛)

</div>

<span id="34"></span>

<div id="page34-div" style="position:relative;width:1440px;height:810px;">

Summary



Running times of the index-based methods:

35

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Method Time**

get(

𝑟

)  

𝑂(1)

set(

𝑟, 𝑒

)

𝑂(1)

add(

𝑟, 𝑒

)

𝑂(𝑛)

remove(

𝑟

)

𝑂(𝑛)

</div>

<span id="35"></span>

<div id="page35-div" style="position:relative;width:1440px;height:810px;">

Node-based (or reference-based) Lists



A **linked list **is a data structure composed of **nodes **linked together



A **node **is a data structure that contains:



data (whatever we want to store in the list)



a pointer to the location of the next element in the list



(sometimes a pointer to the previous element too)

36

CSC 225: Algorithms and Data Structures I -- Anthony Estey

public class Node {

private int data;  
private Node next;  
…

}

7

a

3

Node a = new Node(7, null);  
Node b = new Node(3, null);  
a.next = b;

null

null

b

data

pointer to next   
element

</div>

<span id="36"></span>

<div id="page36-div" style="position:relative;width:1440px;height:810px;">

Iteration implementation



With linked lists, we need to keep a reference to the head of the list.   
From there, we can reach all subsequent elements:

37

CSC 225: Algorithms and Data Structures I -- Anthony Estey

for (Node cur = head; cur \!= null; cur = cur.next) {

System.out.println(cur.data));

}

3

5

6

head

7

9

null

cur

cur

</div>

<span id="37"></span>

<div id="page37-div" style="position:relative;width:1440px;height:810px;">

Iteration



With linked lists, we need to keep a reference to the head of the list.   
From there, we can reach all subsequent elements:

38

CSC 225: Algorithms and Data Structures I -- Anthony Estey

for (Node cur = head; cur \!= null; cur = cur.next) {

System.out.println(cur.data));

}

Node cur = head;  
while (cur \!= null) {

System.out.println(cur.data));  
cur = cur.next;

}

</div>

<span id="38"></span>

<div id="page38-div" style="position:relative;width:1440px;height:810px;">

Insertion



First, determine where to insert the new node



Then, update the next pointers appropriately

39

CSC 225: Algorithms and Data Structures I -- Anthony Estey

…

15

16

19

22

28

head

20

cur

Node n = new Node(20);

n.next = cur.next;

cur.next = n;

null

n

</div>

<span id="39"></span>

<div id="page39-div" style="position:relative;width:1440px;height:810px;">

Order of operations is important\!



Let’s revisit our insertion example, and assume we want to insert a   
node with data value 20 between node’s 19 and 22.

40

CSC 225: Algorithms and Data Structures I -- Anthony Estey

…

15

16

19

22

28

head

20

cur

Node n = new Node(20);

cur.next = n;

n.next = cur.next;

null

n

Node n = new Node(20);

n.next = cur.next;

cur.next = n;

</div>

<span id="40"></span>

<div id="page40-div" style="position:relative;width:1440px;height:810px;">

Removal



First, locate the element *preceding *the one to remove 



Then, update the next pointers so that the deleted node is skipped



Java’s garbage collection will delete of any object that nothing points to

41

CSC 225: Algorithms and Data Structures I -- Anthony Estey

…

15

16

19

22

28

head

cur

cur.next = cur.next.next;

</div>

<span id="41"></span>

<div id="page41-div" style="position:relative;width:1440px;height:810px;">

Adding an item to the front of a list



First, determine where to insert the new node



Then, update the next pointers appropriately

42

CSC 225: Algorithms and Data Structures I -- Anthony Estey

…

15

16

19

22

28

head

12

Node n = new Node(12);

n.next = head;

head = n

null

n

</div>

<span id="42"></span>

<div id="page42-div" style="position:relative;width:1440px;height:810px;">

Adding an item to the back of a list



First, determine where to insert the new node



Then, update the next pointers appropriately

43

CSC 225: Algorithms and Data Structures I -- Anthony Estey

15

16

19

22

28

head

30

cur

Node n = new Node(30);  
cur = head;  
while (cur.next \!= null) {

cur = cur.next;

}  
cur.next = n;

null

n

null

</div>

<span id="43"></span>

<div id="page43-div" style="position:relative;width:1440px;height:810px;">

Adding an item to the back of a list



First, determine where to insert the new node



Then, update the next pointers appropriately

44

CSC 225: Algorithms and Data Structures I -- Anthony Estey

15

16

19

22

28

head

30

cur

Node n = new Node(30, null);  
cur = head;  
while (cur.next \!= null) {

cur = cur.next;

}  
cur.next = n;

null

n

Can we avoid looping through   
the whole list in order to   
insert an item at the back?

</div>

<span id="44"></span>

<div id="page44-div" style="position:relative;width:1440px;height:810px;">

Tail Reference



Idea: We have a reference to the front (head) of our list



Why don’t we do the same with the back (tail)

45

CSC 225: Algorithms and Data Structures I -- Anthony Estey

15

16

19

22

28

head

30

null

n

null

tail

Node n = new Node(30, null);  
tail.next = n;  
tail = n;

Node n = new Node(30, null);  
cur = head;  
while (cur.next \!= null) {

cur = cur.next;

}  
cur.next = n;

</div>

<span id="45"></span>

<div id="page45-div" style="position:relative;width:1440px;height:810px;">

Summary



A linked list allows quick insertion and removal, without the need to   
reshuffle all other items in the list



This allows insertion/removal from the front and back in 

𝑂(1)

time



But accessing the middle elements still requires a traversal to get to the   
location where the insertion or removal should take place. Thus, 

𝑂(𝑛)

.



Next, we will discuss a few variations of a linked list implementation

46

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="46"></span>

<div id="page46-div" style="position:relative;width:1440px;height:810px;">

Doubly-linked list



A **doubly-linked list **is a linked list where each node keeps a reference   
to both the preceding *and *following nodes in the chain.



A **node **is a data structure that contains:



data (whatever we want to store in the list)



a pointer to the location of the next element in the list



**(sometimes a pointer to the previous element too)**

47

CSC 225: Algorithms and Data Structures I -- Anthony Estey

public class Node {

private int data;  
**private Node prev;  
**private Node next;  
…

}

7

a

3

null

b

null

</div>

<span id="47"></span>

<div id="page47-div" style="position:relative;width:1440px;height:810px;">



First, determine where to insert the node 



Then, update pointers so that the order is correct

48

CSC 225: Algorithms and Data Structures I -- Anthony Estey

…

15

16

19

22

28

head

cur

null

Insertion

Node n = new Node(20, null);

// move cur to correct place

n.next = cur.next;  
n.prev = cur;  
cur.next.prev = n;  
cur.next = n;

20

null

n

null

</div>

<span id="48"></span>

<div id="page48-div" style="position:relative;width:1440px;height:810px;">



First, locate the element to remove 



Then, update the next pointers so that the deleted node is skipped

49

CSC 225: Algorithms and Data Structures I -- Anthony Estey

…

15

16

19

22

28

head

cur

null

Removal

cur.next.prev = cur.prev;

cur.prev.next = cur.next;

cur = null;

</div>

<span id="49"></span>

<div id="page49-div" style="position:relative;width:1440px;height:810px;">

Sentinel Nodes



A variation of a Linked List implementation is to use **sentinel **nodes



Sentinel nodes are nodes that go at the front and end of the list



They are essentially **head **and **tail **nodes, but they never store any list data\!



They are just position markers



An empty list consists of just the sentinel nodes:



And list elements are added between them:

50

CSC 225: Algorithms and Data Structures I -- Anthony Estey

head

tail

6

11

15

tail

head

</div>

<span id="50"></span>

<div id="page50-div" style="position:relative;width:1440px;height:810px;">

Position-based List



In our linked lists, we can think of each node as having a **position**



We can view a linked list as a container of elements where each   
element is stored at a position



And the positions are arranged in a linear order relative to one another



Each position also has a data element (the data being stored at that position)



A position is defined relative to its neighbours:



Position 

𝑝

will always be “after” some position 

𝑞

and “before” some position 

𝑠

51

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="51"></span>

<div id="page51-div" style="position:relative;width:1440px;height:810px;">

Position-based List



Using the concept of a position to encapsulate the idea of node in a   
list, we can define a linked list that supports the following operations:



**first(): **return the position of the first element in the list



**last(): **return the position of the last element in the list



**before(**

𝒑

**): **return the position of the element in the list preceding p



**after(**

𝒑

**): **return the position of the element in the list following p



**insertBefore(**

𝒑

**): **insert a new element 

𝑒

into the list before position 

𝑝



**insertAfter(**

𝒑

**): **insert a new element 

𝑒

into the list after position 

𝑝



**remove(**

𝒑

**): **remove the element at position 

𝑝

from the list

52

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="52"></span>

<div id="page52-div" style="position:relative;width:1440px;height:810px;">

Position-based List Implementation



We will work through a Java example together

53

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="53"></span>

<div id="page53-div" style="position:relative;width:1440px;height:810px;">

Summary



Running times of the position-based methods:

54

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Method Time**

first()  

𝑂(1)

last()  

𝑂(1)

before(

𝑝

)  

𝑂(1)

after(

𝑝

)  

𝑂(1)

insertBefore(

𝑝, 𝑒

)

𝑂(1)

insertAfter(

𝑝, 𝑒

)

𝑂(1)

remove(

𝑝

)

𝑂(1)

At first glace, it appears this   
implementation is clearly better   
than an array implementation

It is important to remember   
that accessing an element 

𝑛

spots from the front of the list   
still requires a traversal (

𝑂(𝑛)

). 

The array implementation is   
more efficient for getting or   
replacing at an index (

𝑂(1)

)

</div>

<span id="54"></span>

<div id="page54-div" style="position:relative;width:1440px;height:810px;">

Summary



Running times of the position-based methods:

55

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Method Time**

first()  

𝑂(1)

last()  

𝑂(1)

before(

𝑝

)  

𝑂(1)

after(

𝑝

)  

𝑂(1)

insertBefore(

𝑝, 𝑒

)

𝑂(1)

insertAfter(

𝑝, 𝑒

)

𝑂(1)

remove(

𝑝

)

𝑂(1)

It is important to consider the way   
the program will typically be used.

Will there be frequent insertions   
before or after another item in the   
list? A **linked list **doesn’t require   
shuffling of all subsequent items

Will there be frequent accesses from   
a rank/index? An **array **accesses   
items at any rank immediately

</div>
