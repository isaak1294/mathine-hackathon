---
{
  "doc_type": "slides",
  "source": "/home/isaak/projects/course-to-md/CSC225/Slides/CSC225Unit6ADTs.pdf",
  "pages": 54,
  "avg_landscape": true,
  "words_est_first2pages": 134,
  "hash": "3dae8b15652d867f"
}
---

<span id="1"></span>

<div id="page1-div" style="position:relative;width:1440px;height:810px;">

UnitÂ 06:Â AbstractÂ DataÂ TypesÂ   
(ADTs)

AnthonyÂ Estey

CSCÂ 115: FundamentalsÂ ofÂ Programming II

UniversityÂ ofÂ Victoria

</div>

<span id="2"></span>

<div id="page2-div" style="position:relative;width:1440px;height:810px;">

Data Structures

ïµ

AÂ dataÂ structureÂ isÂ a containerÂ used to storeÂ dataÂ (objects).

ïµ

Typically, thisÂ isÂ done inÂ one of twoÂ ways:

ïµ

Contiguous-basedÂ structure

ïµ

Node-basedÂ structure

ïµ

Although theirÂ implementationsÂ are different,Â both dataÂ structuresÂ canÂ   
storeÂ the sameÂ data,Â and performÂ the sameÂ operationsÂ on thatÂ data

ïµ

For example:Â addÂ andÂ removeÂ studentsÂ from a courseâ€™sÂ waitlist

ïµ

There are tradeoffsÂ associatedÂ withÂ eachÂ implementation:

ïµ

ArraysÂ allowÂ immediateÂ accessÂ toÂ theÂ 

ğ‘–

thÂ elementÂ inÂ collectionÂ (

0Â â‰¤Â ğ‘–Â \<Â ğ‘›

)

ïµ

AÂ linked-listÂ requiresÂ iterationÂ from oneÂ endÂ ofÂ theÂ listÂ toÂ reachÂ theÂ 

ğ‘–

thÂ position

3

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

Array

LinkedÂ List

</div>

<span id="3"></span>

<div id="page3-div" style="position:relative;width:1440px;height:810px;">

Abstract DataÂ Types (ADTs)

ïµ

AnÂ ADTÂ isÂ composedÂ of:

ïµ

AÂ descriptionÂ ofÂ whatÂ dataÂ isÂ storedÂ 

ïµ

AÂ set ofÂ operationsÂ onÂ thatÂ data

ïµ

TheÂ separationÂ of whatÂ somethingÂ does (specification)Â and how itÂ doesÂ   
itÂ (implementation)Â isÂ a fundamentalÂ conceptÂ inÂ engineering\!

4

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

(butÂ notÂ howÂ theÂ dataÂ isÂ stored)

(butÂ notÂ howÂ theÂ operationsÂ areÂ implemented)

</div>

<span id="4"></span>

<div id="page4-div" style="position:relative;width:1440px;height:810px;">

WhyÂ the split?

ïµ

ThinkÂ aboutÂ itÂ from aÂ softwareÂ developmentÂ perspective:

ïµ

When weÂ have specificationsÂ withoutÂ implementationÂ details:

ïµ

This isÂ the perfectÂ medium forÂ whichÂ clientsÂ andÂ developersÂ can communicate

ïµ

ClientsÂ canÂ requestÂ behaviours,Â developersÂ canÂ discussÂ theseÂ requests,Â untilÂ anÂ   
agreementÂ isÂ made

ïµ

ClientsÂ areÂ not programmers,Â theyÂ areÂ notÂ interestedÂ inÂ implementationÂ   
details,Â butÂ theyÂ areÂ interestedÂ inÂ *whatÂ *theÂ programÂ canÂ do

ïµ

DevelopersÂ thenÂ provideÂ anÂ implementationÂ basedÂ onÂ the specificationÂ (theÂ   
clientsÂ *useÂ *the endÂ product,Â butÂ donâ€™tÂ everÂ haveÂ toÂ seeÂ the underlyingÂ code)

5

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="5"></span>

<div id="page5-div" style="position:relative;width:1440px;height:810px;">

Example

ïµ

ADTÂ Dictionary:

ïµ

***What***

dataÂ isÂ stored,Â and whatÂ operationsÂ mustÂ it perform?

ïµ

StoresÂ aÂ pairÂ ofÂ strings,Â representingÂ the wordÂ andÂ definitionÂ (data)

ïµ

Operations:

ïµ

insert(word,Â definition)

ïµ

find(word)

ïµ

delete(word)

ïµ

We useÂ a dataÂ structureÂ to implementÂ anÂ ADT

ïµ

thisÂ isÂ whereÂ the

***how***

comes in

6

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

WeÂ alsoÂ knowÂ the effectÂ operationsÂ haveÂ   
onÂ the data.Â   
If weÂ 

***delete***

a wordÂ from the dictionary,Â 

aÂ subsequentÂ 

***find***

operationÂ shouldÂ fail.Â 

</div>

<span id="6"></span>

<div id="page6-div" style="position:relative;width:1440px;height:810px;">

ImplementingÂ the DictionaryÂ ADT

7

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

insert

delete

find

â€¦

Data structure

Program

(clientÂ view)

requests toÂ 

perform operationÂ 

DictionaryÂ ADT

Operations

resultÂ ofÂ 

operation

Interface

Array

</div>

<span id="7"></span>

<div id="page7-div" style="position:relative;width:1440px;height:810px;">

Client vsÂ Programmer

ïµ

ClientsÂ knowÂ how to useÂ something

ïµ

***What***

operationsÂ areÂ availableÂ andÂ 

***what***

theyÂ do

ïµ

ProgrammersÂ mustÂ decideÂ 

***howÂ ***

to implementÂ theÂ operations

ïµ

TheirÂ choicesÂ mayÂ be influencedÂ by aÂ number ofÂ things:

ïµ

executionÂ speed

ïµ

memory requirementsÂ 

ïµ

maintenanceÂ (debugging,Â scalability,Â etc.)

ïµ

DictionaryÂ example:

ïµ

Clients/users:Â addÂ newÂ wordsÂ toÂ dictionary,Â lookÂ up wordsÂ toÂ seeÂ definitions

ïµ

Programmer:Â determineÂ 

***how***

dataÂ isÂ stored;Â 

***how***

operationsÂ areÂ implemented

8

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="8"></span>

<div id="page8-div" style="position:relative;width:1440px;height:810px;">

The NotionÂ of a Stack

ïµ

CollectionÂ of items

ïµ

Items areÂ returnedÂ inÂ theÂ 

***reverse***

orderÂ theyÂ wereÂ added

ïµ

This isÂ behaviorÂ isÂ oftenÂ abbreviatedÂ LIFO (LastÂ In,Â FirstÂ Out)

9

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

Programming

Algorithms

DataBases

Operating Systems

SoftwareÂ Engineering

</div>

<span id="9"></span>

<div id="page9-div" style="position:relative;width:1440px;height:810px;">

The StackÂ ADT

ïµ

TheÂ StackÂ ADTÂ specifiesÂ the following operations:

ïµ

push(*o*):Â InsertÂ objectÂ *oÂ *ontoÂ the topÂ of theÂ stack

ïµ

pop():Â AccessÂ andÂ removeÂ the objectÂ from theÂ top ofÂ the stack;Â anÂ errorÂ occursÂ   
ifÂ theÂ stack isÂ empty

ïµ

isEmpty():Â DeterminesÂ whetherÂ the stackÂ isÂ currentlyÂ empty

ïµ

top():Â AccessesÂ the objectÂ onÂ top ofÂ the stackÂ withoutÂ removingÂ it;Â anÂ errorÂ   
occurs ifÂ theÂ stack isÂ empty

ïµ

size():Â GetsÂ the currentÂ numberÂ ofÂ objectsÂ inÂ theÂ stack

10

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="10"></span>

<div id="page10-div" style="position:relative;width:1440px;height:810px;">

Stack Examples

ïµ

Things weÂ use all theÂ time:Â 

ïµ

â€œUndoâ€Â functionÂ foundÂ inÂ mostÂ applications

ïµ

BackÂ buttonÂ whenÂ browsingÂ the web

ïµ

Programming:

ïµ

The runtimeÂ environmentâ€™sÂ handlingÂ ofÂ nestedÂ method calls

ïµ

Recursion

ïµ

Problem solving:

ïµ

ApproachesÂ whereÂ aÂ problemÂ isÂ solvedÂ byÂ breakingÂ theÂ problemÂ up into smallerÂ   
versionÂ of theÂ sameÂ problem.Â (Divide-and-conquer)

11

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="11"></span>

<div id="page11-div" style="position:relative;width:1440px;height:810px;">

ïµ

AÂ stackÂ canÂ be implementedÂ inÂ multipleÂ ways:

ïµ

InÂ an array implementation,Â we typicallyÂ haveÂ the following:

ïµ

ğ´

: anÂ 

ğ‘›

\-elementÂ array

ïµ

ğ‘¡

: anÂ integerÂ toÂ keepÂ trackÂ of theÂ indexÂ of theÂ top elementÂ inÂ theÂ array

ïµ

Example:

5

4

3

2

1

0

Stack Implementation

12

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

A

tÂ 2

</div>

<span id="12"></span>

<div id="page12-div" style="position:relative;width:1440px;height:810px;">

ïµ

AÂ stackÂ canÂ be implementedÂ inÂ multipleÂ ways:

ïµ

InÂ an array implementation,Â we typicallyÂ haveÂ the following:

ïµ

ğ´

: anÂ 

ğ‘›

\-elementÂ array

ïµ

ğ‘¡

: anÂ integerÂ toÂ keepÂ trackÂ of theÂ indexÂ of theÂ top elementÂ inÂ theÂ array

ïµ

Example:

ïµ

**push(**

***o***

**)**

5

4

3

2

1

0

Stack Implementation

13

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

A

tÂ 2

*o*

**3**

</div>

<span id="13"></span>

<div id="page13-div" style="position:relative;width:1440px;height:810px;">

3

**2**

ïµ

AÂ stackÂ canÂ be implementedÂ inÂ multipleÂ ways:

ïµ

InÂ an array implementation,Â we typicallyÂ haveÂ the following:

ïµ

ğ´

: anÂ 

ğ‘›

\-elementÂ array

ïµ

ğ‘¡

: anÂ integerÂ toÂ keepÂ trackÂ of theÂ indexÂ of theÂ top elementÂ inÂ theÂ array

ïµ

Example:

ïµ

push(o)

ïµ

**pop()**

5

4

3

2

1

0

Stack Implementation

14

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

A

t

*o*

</div>

<span id="14"></span>

<div id="page14-div" style="position:relative;width:1440px;height:810px;">

The NotionÂ of a Queue

ïµ

CollectionÂ of items

ïµ

Items areÂ returnedÂ inÂ theÂ 

***same***

orderÂ theyÂ wereÂ added

ïµ

This isÂ behaviorÂ isÂ oftenÂ abbreviatedÂ FIFOÂ (FirstÂ In,Â FirstÂ Out)

15

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="15"></span>

<div id="page15-div" style="position:relative;width:1440px;height:810px;">

The QueueÂ ADT

ïµ

TheÂ QueueÂ ADTÂ specifiesÂ the following operations:

ïµ

enqueue(*o*):Â InsertÂ objectÂ *oÂ *at theÂ rearÂ (back)Â of theÂ queue

ïµ

dequeue():Â AccessÂ andÂ removeÂ the objectÂ fromÂ the frontÂ ofÂ theÂ queue;Â anÂ errorÂ   
occurs ifÂ theÂ queueÂ isÂ empty

ïµ

isEmpty():Â DeterminesÂ whetherÂ the queueÂ is currentlyÂ empty

ïµ

front():Â AccessesÂ the objectÂ at theÂ frontÂ of theÂ queueÂ withoutÂ removingÂ it;Â anÂ   
error occursÂ ifÂ theÂ queueÂ isÂ empty

ïµ

size():Â GetsÂ the currentÂ numberÂ ofÂ objectsÂ inÂ theÂ queue

16

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="16"></span>

<div id="page16-div" style="position:relative;width:1440px;height:810px;">

QueueÂ Examples

ïµ

Any timeÂ people waitÂ in line for somethingÂ 

ïµ

the bank,Â the cafeteria,Â etc.

ïµ

WaitlistsÂ for classesÂ here atÂ Uvic\!

17

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="17"></span>

<div id="page17-div" style="position:relative;width:1440px;height:810px;">

ïµ

We willÂ exploreÂ an array-basedÂ implementationÂ ofÂ a queueÂ duringÂ   
lecture

QueueÂ Implementation

18

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="18"></span>

<div id="page18-div" style="position:relative;width:1440px;height:810px;">

QueueÂ implementationÂ withÂ a circular array

19

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**AlgorithmÂ **enqueue(

ğ‘œğ‘ğ‘—

):

**ifÂ **isFull()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ full)

ğ´Â ğ‘Â â†Â ğ‘œğ‘ğ‘—  
ğ‘Â â†Â (ğ‘Â +Â 1)

modÂ 

ğ‘

**AlgorithmÂ **dequeue():

**ifÂ **isEmpty()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ empty)

ğ‘’Â â†Â ğ´Â ğ‘“  
ğ‘“Â â†Â (ğ‘“Â +Â 1)

modÂ 

ğ‘

**return**

ğ‘’

0

1

2

3

4

f

b

</div>

<span id="19"></span>

<div id="page19-div" style="position:relative;width:1440px;height:810px;">

3

QueueÂ implementationÂ withÂ a circular array

20

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**AlgorithmÂ **enqueue(

ğ‘œğ‘ğ‘—

):

**ifÂ **isFull()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ full)

ğ´Â ğ‘Â â†Â ğ‘œğ‘ğ‘—  
ğ‘Â â†Â (ğ‘Â +Â 1)

modÂ 

ğ‘

**AlgorithmÂ **dequeue():

**ifÂ **isEmpty()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ empty)

ğ‘’Â â†Â ğ´Â ğ‘“  
ğ‘“Â â†Â (ğ‘“Â +Â 1)

modÂ 

ğ‘

**return**

ğ‘’

0

1

2

3

4

f

b

enqueue(3);

</div>

<span id="20"></span>

<div id="page20-div" style="position:relative;width:1440px;height:810px;">

33

5

QueueÂ implementationÂ withÂ a circular array

21

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**AlgorithmÂ **enqueue(

ğ‘œğ‘ğ‘—

):

**ifÂ **isFull()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ full)

ğ´Â ğ‘Â â†Â ğ‘œğ‘ğ‘—  
ğ‘Â â†Â (ğ‘Â +Â 1)

modÂ 

ğ‘

**AlgorithmÂ **dequeue():

**ifÂ **isEmpty()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ empty)

ğ‘’Â â†Â ğ´Â ğ‘“  
ğ‘“Â â†Â (ğ‘“Â +Â 1)

modÂ 

ğ‘

**return**

ğ‘’

0

1

2

3

4

f

enqueue(3);

enqueue(5);

b

</div>

<span id="21"></span>

<div id="page21-div" style="position:relative;width:1440px;height:810px;">

3

5

3

5

b

QueueÂ implementationÂ withÂ a circular array

22

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**AlgorithmÂ **enqueue(

ğ‘œğ‘ğ‘—

):

**ifÂ **isFull()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ full)

ğ´Â ğ‘Â â†Â ğ‘œğ‘ğ‘—  
ğ‘Â â†Â (ğ‘Â +Â 1)

modÂ 

ğ‘

**AlgorithmÂ **dequeue():

**ifÂ **isEmpty()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ empty)

ğ‘’Â â†Â ğ´Â ğ‘“  
ğ‘“Â â†Â (ğ‘“Â +Â 1)

modÂ 

ğ‘

**return**

ğ‘’

0

1

2

3

4

f

enqueue(3);  
enqueue(5);

dequeue();

</div>

<span id="22"></span>

<div id="page22-div" style="position:relative;width:1440px;height:810px;">

3

5

3

5

b

QueueÂ implementationÂ withÂ a circular array

23

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**AlgorithmÂ **enqueue(

ğ‘œğ‘ğ‘—

):

**ifÂ **isFull()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ full)

ğ´Â ğ‘Â â†Â ğ‘œğ‘ğ‘—  
ğ‘Â â†Â (ğ‘Â +Â 1)

modÂ 

ğ‘

**AlgorithmÂ **dequeue():

**ifÂ **isEmpty()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ empty)

ğ‘’Â â†Â ğ´Â ğ‘“  
ğ‘“Â â†Â (ğ‘“Â +Â 1)

modÂ 

ğ‘

**return**

ğ‘’

0

1

2

3

4

enqueue(3);  
enqueue(5);  
dequeue();

f

dequeue();

</div>

<span id="23"></span>

<div id="page23-div" style="position:relative;width:1440px;height:810px;">

3

5

3

5

b

QueueÂ implementationÂ withÂ a circular array

24

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**AlgorithmÂ **enqueue(

ğ‘œğ‘ğ‘—

):

**ifÂ **isFull()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ full)

ğ´Â ğ‘Â â†Â ğ‘œğ‘ğ‘—  
ğ‘Â â†Â (ğ‘Â +Â 1)

modÂ 

ğ‘

**AlgorithmÂ **dequeue():

**ifÂ **isEmpty()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ empty)

ğ‘’Â â†Â ğ´Â ğ‘“  
ğ‘“Â â†Â (ğ‘“Â +Â 1)

modÂ 

ğ‘

**return**

ğ‘’

0

1

2

3

4

enqueue(3);  
enqueue(5);  
dequeue();

f

dequeue();

</div>

<span id="24"></span>

<div id="page24-div" style="position:relative;width:1440px;height:810px;">

3

5

3

5

b

QueueÂ implementationÂ withÂ a circular array

25

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**AlgorithmÂ **enqueue(

ğ‘œğ‘ğ‘—

):

**ifÂ **isFull()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ full)

ğ´Â ğ‘Â â†Â ğ‘œğ‘ğ‘—  
ğ‘Â â†Â (ğ‘Â +Â 1)

modÂ 

ğ‘

**AlgorithmÂ **dequeue():

**ifÂ **isEmpty()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ empty)

ğ‘’Â â†Â ğ´Â ğ‘“  
ğ‘“Â â†Â (ğ‘“Â +Â 1)

modÂ 

ğ‘

**return**

ğ‘’

0

1

2

3

4

enqueue(3);  
enqueue(5);  
dequeue();

f

dequeue();

enqueue(7);  
enqueue(2);  
enqueue(1);  
enqueue(4);  
enqueue(5);

3

5

7

3

5

7

2

3

5

7

2

1

4

5

7

2

1

4

5

7

2

1

</div>

<span id="25"></span>

<div id="page25-div" style="position:relative;width:1440px;height:810px;">

3

5

4

5

7

2

1

b

QueueÂ implementationÂ withÂ a circular array

26

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**AlgorithmÂ **enqueue(

ğ‘œğ‘ğ‘—

):

**ifÂ **isFull()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ full)

ğ´Â ğ‘Â â†Â ğ‘œğ‘ğ‘—  
ğ‘Â â†Â (ğ‘Â +Â 1)

modÂ 

ğ‘

**AlgorithmÂ **dequeue():

**ifÂ **isEmpty()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ empty)

ğ‘’Â â†Â ğ´Â ğ‘“  
ğ‘“Â â†Â (ğ‘“Â +Â 1)

modÂ 

ğ‘

**return**

ğ‘’

0

1

2

3

4

f

enqueue(3);  
enqueue(5);  
dequeue();  
dequeue();  
enqueue(7);  
enqueue(2);  
enqueue(1);  
enqueue(4);  
enqueue(5);

</div>

<span id="26"></span>

<div id="page26-div" style="position:relative;width:1440px;height:810px;">

**AlgorithmÂ **dequeue():

**ifÂ **isEmpty()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ empty)

ğ‘’Â â†Â ğ´Â ğ‘“  
ğ‘“Â â†Â (ğ‘“Â +Â 1)

modÂ 

ğ‘

ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡Â â†Â ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡Â âˆ’Â 1

**return**

ğ‘’

**AlgorithmÂ **enqueue(

ğ‘œğ‘ğ‘—

):

**ifÂ **isFull()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ full)

ğ´Â ğ‘Â â†Â ğ‘œğ‘ğ‘—  
ğ‘Â â†Â (ğ‘Â +Â 1)

modÂ 

ğ‘

ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡Â â†Â ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡Â +Â 1

3

5

4

5

7

2

1

b

QueueÂ implementationÂ withÂ a circular array

27

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

0

1

2

3

4

f

enqueue(3);  
enqueue(5);  
dequeue();  
dequeue();  
enqueue(7);  
enqueue(2);  
enqueue(1);  
enqueue(4);  
enqueue(5);

**AlgorithmÂ **isFull():

**return**

ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡Â =Â ğ‘

**AlgorithmÂ **isEmpty():

**return**

ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡Â =Â 0

MethodÂ 1: UseÂ a countÂ variable

Pros:

\-Â simplicity.Â BothÂ isFullÂ andÂ isEmpty

areÂ easyÂ toÂ implement

Cons:

\-Â MemoryÂ (allocatedÂ anotherÂ variable)  
\-Â additionalÂ operationsÂ toÂ update theÂ  Â 

variableÂ everyÂ enqueueÂ andÂ dequeue

</div>

<span id="27"></span>

<div id="page27-div" style="position:relative;width:1440px;height:810px;">

4

5

7

2

1

4

7

2

1

**AlgorithmÂ **dequeue():

**ifÂ **isEmpty()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ empty)

ğ‘’Â â†Â ğ´Â ğ‘“  
ğ‘“Â â†Â (ğ‘“Â +Â 1)

modÂ 

ğ‘

**return**

ğ‘’

**AlgorithmÂ **enqueue(

ğ‘œğ‘ğ‘—

):

**ifÂ **isFull()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ full)

ğ´Â ğ‘Â â†Â ğ‘œğ‘ğ‘—  
ğ‘Â â†Â (ğ‘Â +Â 1)

modÂ 

ğ‘

b

QueueÂ implementationÂ withÂ a circular array

28

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

0

1

2

3

4

f

enqueue(3);  
enqueue(5);  
dequeue();  
dequeue();  
enqueue(7);  
enqueue(2);  
enqueue(1);  
enqueue(4);  
enqueue(5);

**AlgorithmÂ **isFull():

**return**

ğ‘Â +Â 1

modÂ 

ğ‘Â =Â ğ‘“

**AlgorithmÂ **isEmpty():

**return**

ğ‘“Â =Â ğ‘

MethodÂ 2: FullÂ whenÂ 

ğ‘ ğ‘–ğ‘§ğ‘’Â =Â ğ‘Â âˆ’Â 1

Pros:

\-Â Speed.Â Fewest operationsÂ required

Cons:

\-Â ArrayÂ memory isÂ neverÂ fully utilizedÂ Â  Â 

(alwaysÂ atÂ leastÂ 1Â unusedÂ spot)

4

5

7

2

1

3

5

2

6

b

0

1

2

3

4

f

</div>

<span id="28"></span>

<div id="page28-div" style="position:relative;width:1440px;height:810px;">

**AlgorithmÂ **dequeue():

**ifÂ **isEmpty()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ empty)

ğ‘’Â â†Â ğ´Â ğ‘“  
ğ‘“Â â†Â (ğ‘“Â +Â 1)

modÂ 

ğ‘

**ifÂ **

ğ‘“Â =Â ğ‘

**then**

ğ‘“Â â†Â âˆ’1

**return**

ğ‘’

\-1

0

1

2

3

4

**AlgorithmÂ **enqueue(

ğ‘œğ‘ğ‘—

):

**ifÂ **isFull()Â **then**

**returnÂ **an errorÂ (queueÂ isÂ full)

**else ifÂ **isEmpty()Â **then**

ğ‘“Â â†Â 0  
ğ‘Â â†Â 0

ğ´Â ğ‘Â â†Â ğ‘œğ‘ğ‘—  
ğ‘Â â†Â (ğ‘Â +Â 1)

modÂ 

ğ‘

3

5

b

QueueÂ implementationÂ withÂ a circular array

29

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

f

enqueue(3);  
enqueue(8);  
enqueue(2);  
dequeue();  
enqueue(5);

**AlgorithmÂ **isFull():

**return**

ğ‘“Â =Â ğ‘

**AlgorithmÂ **isEmpty():

**return**

ğ‘“Â =Â âˆ’1

MethodÂ 3:Â 

ğ‘“,Â ğ‘Â =Â âˆ’1

whenÂ empty

Pros:

\-Â RelativelyÂ efficientÂ (only re-assignÂ 

ğ‘“

orÂ 

ğ‘

whenÂ the queueÂ isÂ fullÂ orÂ empty)

\-Â ArrayÂ memory fully utilized

Cons:

\-Â Additional conditional operationsÂ on Â Â 

everyÂ enqueueÂ andÂ dequeue

enqueue(4);  
enqueue(9);

33

8

3

8

2

3

8

2

3

8

2

5

3

8

2

5

4

9

8

2

5

4

</div>

<span id="29"></span>

<div id="page29-div" style="position:relative;width:1440px;height:810px;">

The NotionÂ of a List

ïµ

CollectionÂ of items

ïµ

ElementsÂ canÂ be insertedÂ andÂ removed inÂ 

***any***

order

ïµ

Any elementÂ canÂ be accessedÂ at anyÂ givenÂ timeÂ byÂ theirÂ positionÂ inÂ the list

ïµ

NotÂ justÂ theÂ frontÂ (Queue)Â orÂ topÂ (Stack)Â element

30

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="30"></span>

<div id="page30-div" style="position:relative;width:1440px;height:810px;">

Index-BasedÂ Lists

ïµ

We canÂ uniquely referÂ to eachÂ element in the listÂ containingÂ 

ğ‘›

elementsÂ using anÂ integerÂ inÂ the rangeÂ 

\[0,Â ğ‘›Â âˆ’Â 1\]

ïµ

WeÂ defineÂ theÂ **indexÂ **orÂ **rankÂ **of anÂ elementÂ 

ğ‘’

inÂ aÂ list byÂ the numberÂ ofÂ 

elementsÂ thatÂ come beforeÂ 

ğ‘’

in the list

ïµ

HenceÂ the firstÂ elementÂ isÂ at indexÂ 

0

, andÂ the lastÂ elementÂ isÂ at indexÂ 

ğ‘›Â âˆ’Â 1

ïµ

Index-based listsÂ support theÂ followingÂ operations:

ïµ

**get(**

***r***

**):Â **ReturnÂ theÂ elementÂ inÂ theÂ list withÂ indexÂ 

ğ‘Ÿ

.

ïµ

**set(**

***r,Â e***

**):Â **ReplaceÂ elementÂ atÂ indexÂ 

ğ‘Ÿ

withÂ 

ğ‘’

andÂ returnÂ the elementÂ replaced.

ïµ

**add(**

***r,Â e***

**):Â **InsertÂ aÂ newÂ elementÂ 

ğ‘’

intoÂ the listÂ at indexÂ 

ğ‘Ÿ

.

ïµ

**remove(**

***r***

**):Â **RemoveÂ theÂ elementÂ at indexÂ 

ğ‘Ÿ

fromÂ theÂ list.

31

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="31"></span>

<div id="page31-div" style="position:relative;width:1440px;height:810px;">

Array ImplementationÂ of a List

ïµ

TheÂ **get(**

***r***

**)Â **andÂ **set(**

***r,Â e***

**)Â **operationsÂ canÂ be done inÂ 

ğ‘¶(ğŸ)

time:

ïµ

**get(3)**

ïµ

**set(5,Â 12)**

32

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

2

3

5

7

9

13

14

16

20

22

0

1

2

3

4

5

6

7

8

9

returnsÂ 7  
returnsÂ 13

12

12

</div>

<span id="32"></span>

<div id="page32-div" style="position:relative;width:1440px;height:810px;">

ListsÂ â€“Â Array Implementation

ïµ

**add(**

***r, e***

**)Â **cannotÂ be done inÂ 

ğ‘‚(1)

time

ïµ

**add(**

***3,Â 6***

**):**

33

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

2

3

5

7

9

13

14

16

20

0

1

2

3

4

5

6

7

8

9

20

14

13

9

7

16

6

6

On average,Â half ofÂ the elementsÂ   
need to be shuffled:Â Â  Â Â Â 

ğ‘‚(ğ‘›)

**AlgorithmÂ **add(

ğ‘Ÿ,Â ğ‘’

):

**if**

ğ‘›Â =Â ğ‘

**then**

**returnÂ errorÂ **(ListÂ isÂ full)

**if**

ğ‘ŸÂ \<Â ğ‘›

**then**

**for**

ğ‘–Â â†Â ğ‘›Â âˆ’Â 1

toÂ 

ğ‘Ÿ

**do**

ğ´\[ğ‘–Â +Â 1\]Â â†Â ğ´\[ğ‘–\]

ğ´\[ğ‘Ÿ\]Â â†Â ğ‘’  
ğ‘›Â â†Â ğ‘›Â +Â 1

</div>

<span id="33"></span>

<div id="page33-div" style="position:relative;width:1440px;height:810px;">

ListsÂ â€“Â Array Implementation

ïµ

**remove(**

***r***

**)Â **hasÂ the sameÂ problem

ïµ

**remove(**

***6***

**):**

34

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

2

3

5

6

9

13

14

16

20

0

1

2

3

4

5

6

7

8

9

20

14

13

9

7

16

13

**AlgorithmÂ **remove(

ğ‘Ÿ

):

**if**

ğ‘ŸÂ \<Â ğ‘›Â âˆ’Â 1

**then**

ğ‘’Â â†Â ğ´\[ğ‘Ÿ\]

**for**

ğ‘–Â â†Â ğ‘Ÿ

toÂ 

ğ‘›Â âˆ’Â 2

**do**

ğ´Â ğ‘–Â â†Â ğ´Â ğ‘–Â +Â 1

ğ‘›Â â†Â ğ‘›Â +Â 1

**return**

ğ‘’

RuntimeÂ ofÂ **remove(**

***r***

**)**: Â 

ğ‘‚(ğ‘›)

</div>

<span id="34"></span>

<div id="page34-div" style="position:relative;width:1440px;height:810px;">

Summary

ïµ

Running timesÂ of the index-basedÂ methods:

35

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**MethodÂ Time**

get(

ğ‘Ÿ

) Â 

ğ‘‚(1)

set(

ğ‘Ÿ,Â ğ‘’

)

ğ‘‚(1)

add(

ğ‘Ÿ,Â ğ‘’

)

ğ‘‚(ğ‘›)

remove(

ğ‘Ÿ

)

ğ‘‚(ğ‘›)

</div>

<span id="35"></span>

<div id="page35-div" style="position:relative;width:1440px;height:810px;">

Node-based (orÂ reference-based)Â Lists

ïµ

AÂ **linked listÂ **isÂ a dataÂ structureÂ composedÂ ofÂ **nodesÂ **linked together

ïµ

AÂ **nodeÂ **isÂ a dataÂ structureÂ thatÂ contains:

ïµ

dataÂ (whateverÂ weÂ wantÂ toÂ storeÂ inÂ the list)

ïµ

aÂ pointerÂ toÂ the locationÂ ofÂ theÂ nextÂ elementÂ inÂ theÂ list

ïµ

(sometimesÂ a pointerÂ toÂ the previousÂ elementÂ too)

36

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

publicÂ class NodeÂ {

privateÂ intÂ data;  
privateÂ Node next;  
â€¦

}

7

a

3

Node aÂ = new Node(7,Â null);  
Node bÂ = new Node(3,Â null);  
a.nextÂ = b;

null

null

b

data

pointerÂ toÂ nextÂ   
element

</div>

<span id="36"></span>

<div id="page36-div" style="position:relative;width:1440px;height:810px;">

IterationÂ implementation

ïµ

WithÂ linked lists,Â we need toÂ keepÂ a reference to theÂ head of the list.Â   
From there,Â we can reachÂ all subsequentÂ elements:

37

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

forÂ (NodeÂ cur =Â head;Â curÂ \!= null;Â curÂ =Â cur.next)Â {

System.out.println(cur.data));

}

3

5

6

head

7

9

null

cur

cur

</div>

<span id="37"></span>

<div id="page37-div" style="position:relative;width:1440px;height:810px;">

Iteration

ïµ

WithÂ linked lists,Â we need toÂ keepÂ a reference to theÂ head of the list.Â   
From there,Â we can reachÂ all subsequentÂ elements:

38

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

forÂ (NodeÂ cur =Â head;Â curÂ \!= null;Â curÂ =Â cur.next)Â {

System.out.println(cur.data));

}

Node curÂ = head;  
whileÂ (cur \!= null)Â {

System.out.println(cur.data));  
curÂ =Â cur.next;

}

</div>

<span id="38"></span>

<div id="page38-div" style="position:relative;width:1440px;height:810px;">

Insertion

ïµ

First,Â determineÂ where to insertÂ the new node

ïµ

Then, updateÂ the next pointersÂ appropriately

39

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

â€¦

15

16

19

22

28

head

20

cur

NodeÂ nÂ =Â newÂ Node(20);

n.nextÂ =Â cur.next;

cur.nextÂ =Â n;

null

n

</div>

<span id="39"></span>

<div id="page39-div" style="position:relative;width:1440px;height:810px;">

OrderÂ of operationsÂ is important\!

ïµ

Letâ€™s revisitÂ our insertionÂ example,Â and assumeÂ we wantÂ to insertÂ aÂ   
node withÂ dataÂ value 20 betweenÂ nodeâ€™s 19Â and 22.

40

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

â€¦

15

16

19

22

28

head

20

cur

NodeÂ nÂ =Â newÂ Node(20);

cur.nextÂ =Â n;

n.nextÂ =Â cur.next;

null

n

NodeÂ nÂ =Â newÂ Node(20);

n.nextÂ =Â cur.next;

cur.nextÂ =Â n;

</div>

<span id="40"></span>

<div id="page40-div" style="position:relative;width:1440px;height:810px;">

Removal

ïµ

First,Â locateÂ the elementÂ *precedingÂ *the one toÂ removeÂ 

ïµ

Then, updateÂ the next pointersÂ so thatÂ the deletedÂ node isÂ skipped

ïµ

Javaâ€™sÂ garbageÂ collectionÂ willÂ deleteÂ ofÂ anyÂ objectÂ thatÂ nothingÂ pointsÂ to

41

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

â€¦

15

16

19

22

28

head

cur

cur.nextÂ =Â cur.next.next;

</div>

<span id="41"></span>

<div id="page41-div" style="position:relative;width:1440px;height:810px;">

AddingÂ an itemÂ to theÂ front of a list

ïµ

First,Â determineÂ where to insertÂ the new node

ïµ

Then, updateÂ the next pointersÂ appropriately

42

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

â€¦

15

16

19

22

28

head

12

NodeÂ nÂ =Â newÂ Node(12);

n.nextÂ =Â head;

headÂ =Â n

null

n

</div>

<span id="42"></span>

<div id="page42-div" style="position:relative;width:1440px;height:810px;">

AddingÂ an itemÂ to theÂ back of a list

ïµ

First,Â determineÂ where to insertÂ the new node

ïµ

Then, updateÂ the next pointersÂ appropriately

43

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

15

16

19

22

28

head

30

cur

NodeÂ nÂ =Â newÂ Node(30);  
curÂ =Â head;  
whileÂ (cur.nextÂ \!=Â null)Â {

curÂ =Â cur.next;

}  
cur.nextÂ =Â n;

null

n

null

</div>

<span id="43"></span>

<div id="page43-div" style="position:relative;width:1440px;height:810px;">

AddingÂ an itemÂ to theÂ back of a list

ïµ

First,Â determineÂ where to insertÂ the new node

ïµ

Then, updateÂ the next pointersÂ appropriately

44

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

15

16

19

22

28

head

30

cur

NodeÂ nÂ =Â newÂ Node(30,Â null);  
curÂ =Â head;  
whileÂ (cur.nextÂ \!=Â null)Â {

curÂ =Â cur.next;

}  
cur.nextÂ =Â n;

null

n

CanÂ weÂ avoidÂ loopingÂ throughÂ   
theÂ wholeÂ listÂ in orderÂ toÂ   
insertÂ anÂ itemÂ at theÂ back?

</div>

<span id="44"></span>

<div id="page44-div" style="position:relative;width:1440px;height:810px;">

TailÂ Reference

ïµ

Idea: We haveÂ a reference to the frontÂ (head) of ourÂ list

ïµ

WhyÂ donâ€™tÂ weÂ doÂ theÂ same withÂ the backÂ (tail)

45

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

15

16

19

22

28

head

30

null

n

null

tail

NodeÂ nÂ =Â newÂ Node(30,Â null);  
tail.nextÂ =Â n;  
tailÂ =Â n;

NodeÂ nÂ =Â newÂ Node(30,Â null);  
curÂ =Â head;  
whileÂ (cur.nextÂ \!=Â null)Â {

curÂ =Â cur.next;

}  
cur.nextÂ =Â n;

</div>

<span id="45"></span>

<div id="page45-div" style="position:relative;width:1440px;height:810px;">

Summary

ïµ

AÂ linkedÂ listÂ allowsÂ quickÂ insertionÂ and removal,Â withoutÂ the need toÂ   
reshuffleÂ all otherÂ itemsÂ inÂ the list

ïµ

This allowsÂ insertion/removalÂ from theÂ frontÂ andÂ backÂ inÂ 

ğ‘‚(1)

time

ïµ

ButÂ accessingÂ the middleÂ elementsÂ stillÂ requiresÂ aÂ traversalÂ toÂ get to theÂ   
locationÂ whereÂ the insertionÂ orÂ removalÂ shouldÂ takeÂ place.Â Thus,Â 

ğ‘‚(ğ‘›)

.

ïµ

Next, we willÂ discussÂ a few variationsÂ ofÂ a linked listÂ implementation

46

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="46"></span>

<div id="page46-div" style="position:relative;width:1440px;height:810px;">

Doubly-linked list

ïµ

AÂ **doubly-linked listÂ **isÂ a linked listÂ where eachÂ node keepsÂ a referenceÂ   
to bothÂ the precedingÂ *andÂ *followingÂ nodes in the chain.

ïµ

AÂ **nodeÂ **isÂ a dataÂ structureÂ thatÂ contains:

ïµ

dataÂ (whateverÂ weÂ wantÂ toÂ storeÂ inÂ the list)

ïµ

aÂ pointerÂ toÂ the locationÂ ofÂ theÂ nextÂ elementÂ inÂ theÂ list

ïµ

**(sometimesÂ a pointerÂ toÂ the previousÂ elementÂ too)**

47

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

publicÂ class NodeÂ {

privateÂ intÂ data;  
**privateÂ NodeÂ prev;  
**privateÂ Node next;  
â€¦

}

7

a

3

null

b

null

</div>

<span id="47"></span>

<div id="page47-div" style="position:relative;width:1440px;height:810px;">

ïµ

First,Â determineÂ where to insertÂ the nodeÂ 

ïµ

Then, updateÂ pointersÂ so thatÂ the orderÂ isÂ correct

48

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

â€¦

15

16

19

22

28

head

cur

null

Insertion

NodeÂ nÂ =Â newÂ Node(20,Â null);

//Â moveÂ curÂ toÂ correctÂ place

n.nextÂ =Â cur.next;  
n.prevÂ =Â cur;  
cur.next.prevÂ =Â n;  
cur.nextÂ =Â n;

20

null

n

null

</div>

<span id="48"></span>

<div id="page48-div" style="position:relative;width:1440px;height:810px;">

ïµ

First,Â locateÂ the elementÂ to removeÂ 

ïµ

Then, updateÂ the next pointersÂ so thatÂ the deletedÂ node isÂ skipped

49

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

â€¦

15

16

19

22

28

head

cur

null

Removal

cur.next.prevÂ =Â cur.prev;

cur.prev.nextÂ =Â cur.next;

curÂ =Â null;

</div>

<span id="49"></span>

<div id="page49-div" style="position:relative;width:1440px;height:810px;">

SentinelÂ Nodes

ïµ

AÂ variationÂ of a LinkedÂ ListÂ implementationÂ isÂ to useÂ **sentinelÂ **nodes

ïµ

SentinelÂ nodes are nodesÂ thatÂ go atÂ the frontÂ and end of the list

ïµ

TheyÂ areÂ essentiallyÂ **headÂ **andÂ **tailÂ **nodes,Â butÂ theyÂ neverÂ storeÂ anyÂ list data\!

ïµ

TheyÂ areÂ justÂ positionÂ markers

ïµ

AnÂ emptyÂ listÂ consistsÂ of justÂ the sentinelÂ nodes:

ïµ

And list elementsÂ areÂ addedÂ betweenÂ them:

50

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

head

tail

6

11

15

tail

head

</div>

<span id="50"></span>

<div id="page50-div" style="position:relative;width:1440px;height:810px;">

Position-based List

ïµ

InÂ our linked lists,Â we can thinkÂ of each node asÂ havingÂ aÂ **position**

ïµ

We canÂ viewÂ a linkedÂ listÂ asÂ a containerÂ of elementsÂ where eachÂ   
element isÂ storedÂ at aÂ position

ïµ

And theÂ positionsÂ areÂ arrangedÂ inÂ aÂ linearÂ orderÂ relativeÂ toÂ oneÂ another

ïµ

Each positionÂ alsoÂ hasÂ aÂ dataÂ elementÂ (theÂ dataÂ beingÂ storedÂ at thatÂ position)

ïµ

AÂ positionÂ isÂ defined relativeÂ to itsÂ neighbours:

ïµ

PositionÂ 

ğ‘

willÂ alwaysÂ be â€œafterâ€Â some positionÂ 

ğ‘

andÂ â€œbeforeâ€Â some positionÂ 

ğ‘ 

51

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="51"></span>

<div id="page51-div" style="position:relative;width:1440px;height:810px;">

Position-based List

ïµ

Using theÂ conceptÂ of aÂ positionÂ to encapsulateÂ the ideaÂ of node in aÂ   
list,Â we can defineÂ a linkedÂ listÂ thatÂ supportsÂ the following operations:

ïµ

**first():Â **returnÂ the positionÂ ofÂ theÂ firstÂ elementÂ inÂ theÂ list

ïµ

**last():Â **returnÂ the positionÂ ofÂ theÂ lastÂ elementÂ inÂ theÂ list

ïµ

**before(**

ğ’‘

**):Â **returnÂ the positionÂ of theÂ elementÂ inÂ theÂ list precedingÂ p

ïµ

**after(**

ğ’‘

**):Â **returnÂ theÂ positionÂ of theÂ elementÂ inÂ theÂ listÂ followingÂ p

ïµ

**insertBefore(**

ğ’‘

**):Â **insertÂ a newÂ elementÂ 

ğ‘’

intoÂ theÂ list beforeÂ positionÂ 

ğ‘

ïµ

**insertAfter(**

ğ’‘

**):Â **insertÂ aÂ newÂ elementÂ 

ğ‘’

intoÂ the listÂ afterÂ positionÂ 

ğ‘

ïµ

**remove(**

ğ’‘

**):Â **removeÂ the elementÂ at positionÂ 

ğ‘

fromÂ the list

52

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="52"></span>

<div id="page52-div" style="position:relative;width:1440px;height:810px;">

Position-based List Implementation

ïµ

We willÂ work through aÂ JavaÂ exampleÂ together

53

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="53"></span>

<div id="page53-div" style="position:relative;width:1440px;height:810px;">

Summary

ïµ

Running timesÂ of the position-basedÂ methods:

54

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**MethodÂ Time**

first()Â Â 

ğ‘‚(1)

last()Â Â 

ğ‘‚(1)

before(

ğ‘

)Â Â 

ğ‘‚(1)

after(

ğ‘

) Â 

ğ‘‚(1)

insertBefore(

ğ‘,Â ğ‘’

)

ğ‘‚(1)

insertAfter(

ğ‘,Â ğ‘’

)

ğ‘‚(1)

remove(

ğ‘

)

ğ‘‚(1)

At first glace,Â it appearsÂ thisÂ   
implementationÂ isÂ clearlyÂ betterÂ   
thanÂ anÂ arrayÂ implementation

It is importantÂ toÂ rememberÂ   
thatÂ accessingÂ anÂ elementÂ 

ğ‘›

spotsÂ from theÂ frontÂ of theÂ listÂ   
stillÂ requiresÂ a traversalÂ (

ğ‘‚(ğ‘›)

).Â 

The arrayÂ implementationÂ isÂ   
more efficientÂ for gettingÂ orÂ   
replacingÂ at anÂ indexÂ (

ğ‘‚(1)

)

</div>

<span id="54"></span>

<div id="page54-div" style="position:relative;width:1440px;height:810px;">

Summary

ïµ

Running timesÂ of the position-basedÂ methods:

55

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**MethodÂ Time**

first()Â Â 

ğ‘‚(1)

last()Â Â 

ğ‘‚(1)

before(

ğ‘

)Â Â 

ğ‘‚(1)

after(

ğ‘

) Â 

ğ‘‚(1)

insertBefore(

ğ‘,Â ğ‘’

)

ğ‘‚(1)

insertAfter(

ğ‘,Â ğ‘’

)

ğ‘‚(1)

remove(

ğ‘

)

ğ‘‚(1)

It isÂ importantÂ toÂ considerÂ theÂ wayÂ   
the programÂ willÂ typicallyÂ be used.

WillÂ thereÂ beÂ frequentÂ insertionsÂ   
beforeÂ or afterÂ anotherÂ itemÂ in theÂ   
list?Â AÂ **linkedÂ listÂ **doesnâ€™tÂ requireÂ   
shufflingÂ of allÂ subsequentÂ items

WillÂ thereÂ beÂ frequentÂ accessesÂ fromÂ   
aÂ rank/index?Â AnÂ **arrayÂ **accessesÂ   
itemsÂ at anyÂ rank immediately

</div>
