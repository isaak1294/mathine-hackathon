---
{
  "doc_type": "slides",
  "source": "/home/isaak/projects/course-to-md/CSC225/Slides/CSC225Unit3Recursion.pdf",
  "pages": 13,
  "avg_landscape": true,
  "words_est_first2pages": 151,
  "hash": "0935c2e390952510"
}
---

<span id="1"></span>

<div id="page1-div" style="position:relative;width:1440px;height:810px;">

UnitÂ 03:  
Recursion

AnthonyÂ Estey

CSCÂ 225:Â Algorithms andÂ Data StructuresÂ I

UniversityÂ ofÂ Victoria

\*ThanksÂ toÂ Dr.Â RichÂ LittleÂ atÂ theÂ UniversityÂ ofÂ VictoriaÂ forÂ providingÂ someÂ ofÂ theÂ contentsÂ ofÂ theseÂ slides

</div>

<span id="2"></span>

<div id="page2-div" style="position:relative;width:1440px;height:810px;">

UnitÂ 03Â Overview

ïµ

SupplementalÂ Reading:

ïµ

Algorithm DesignÂ andÂ Analysis.Â *MichaelÂ GoodrichÂ andÂ RobertoÂ Tamassia*

ïµ

PagesÂ 10,Â 19-25

ïµ

Learning Objectives:Â (You shouldÂ be ableÂ toâ€¦)

ïµ

understandÂ why we willÂ useÂ pseudocodeÂ toÂ supportÂ or analysisÂ of algorithmsÂ   
andÂ dataÂ structures

ïµ

understandÂ the syntaxÂ of pseudocode,Â andÂ howÂ it maps toÂ operationsÂ inÂ aÂ   
programmingÂ languageÂ likeÂ Java,Â C, orÂ C++

ïµ

understandÂ the methodologyÂ we willÂ useÂ inÂ thisÂ courseÂ toÂ analyzeÂ algorithmsÂ   
andÂ dataÂ structures,Â basedÂ onÂ the sizeÂ of theÂ inputÂ data,Â *n*

ïµ

determineÂ the numberÂ ofÂ operationsÂ requiredÂ toÂ executeÂ anÂ algorithm throughÂ   
anÂ analysisÂ of pseudocode

2

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="3"></span>

<div id="page3-div" style="position:relative;width:1440px;height:810px;">

WhatÂ is recursion?

ïµ

AÂ divide-and-conquerÂ approachÂ to solvingÂ problems, whereÂ the solutionÂ   
depends on solutionsÂ to smallerÂ instancesÂ ofÂ theÂ *sameÂ *problem

ïµ

AÂ recursiveÂ solutionÂ to a problemÂ byÂ usingÂ functions/methodsÂ thatÂ callÂ   
themselvesÂ withinÂ their own code

ïµ

Recursion is one ofÂ theÂ central ideasÂ ofÂ computerÂ science;Â we willÂ seeÂ   
a lot ofÂ recursionÂ solutionsÂ asÂ we exploreÂ differentÂ algorithmsÂ and dataÂ   
structuresÂ throughout thisÂ course

3

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="4"></span>

<div id="page4-div" style="position:relative;width:1440px;height:810px;">

factorial(

5

)

returnÂ 

5Â âˆ—

factorial(

4

)

returnÂ 

4Â âˆ—

factorial(

3

)

returnÂ 

3Â âˆ—

factorial(

2

)

returnÂ 

2Â âˆ—

factorial(

1

)

Example

4

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**AlgorithmÂ **factorial(

ğ‘›

):

ğ‘°ğ’ğ’‘ğ’–ğ’•

:Â AnÂ integerÂ 

ğ‘›Â â‰¥Â 0.

ğ‘¶ğ’–ğ’•ğ’‘ğ’–ğ’•

:Â 

ğ‘›\!.

**if**

ğ‘›Â â‰¤Â 1

**then**

**return**

1

**returnÂ **

ğ‘›Â âˆ—

factorial(

ğ‘›Â âˆ’Â 1

)

returnÂ 

1

</div>

<span id="5"></span>

<div id="page5-div" style="position:relative;width:1440px;height:810px;">

factorial(

5

)

returnÂ 

5Â âˆ—

factorial(

4

)

returnÂ 

4Â âˆ—

factorial(

3

)

returnÂ 

3Â âˆ—

factorial(

2

)

returnÂ 

2Â âˆ—

factorial(

1

)

Example

5

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**AlgorithmÂ **factorial(

ğ‘›

):

ğ‘°ğ’ğ’‘ğ’–ğ’•

:Â AnÂ integerÂ 

ğ‘›Â â‰¥Â 0.

ğ‘¶ğ’–ğ’•ğ’‘ğ’–ğ’•

:Â 

ğ‘›\!.

**if**

ğ‘›Â â‰¤Â 1

**then**

**return**

1

**returnÂ **

ğ‘›Â âˆ—

factorial(

ğ‘›Â âˆ’Â 1

)

24

6

2

1

returnÂ 

1

</div>

<span id="6"></span>

<div id="page6-div" style="position:relative;width:1440px;height:810px;">

factorial(

5

)

returnÂ 

5Â âˆ—

factorial(

4

)

returnÂ 

4Â âˆ—

factorial(

3

)

returnÂ 

3Â âˆ—

factorial(

2

)

returnÂ 

2Â âˆ—

factorial(

1

)

Example

6

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**AlgorithmÂ **factorial(

ğ‘›

):

ğ‘°ğ’ğ’‘ğ’–ğ’•

:Â AnÂ integerÂ 

ğ‘›Â â‰¥Â 0.

ğ‘¶ğ’–ğ’•ğ’‘ğ’–ğ’•

:Â 

ğ‘›\!.

**if**

ğ‘›Â â‰¤Â 1

**then**

**return**

1

**returnÂ **

ğ‘›Â âˆ—

factorial(

ğ‘›Â âˆ’Â 1

)

24

6

2

1

returnÂ 

1

returnÂ 2

returnÂ 6

return 24

returnÂ 120

</div>

<span id="7"></span>

<div id="page7-div" style="position:relative;width:1440px;height:810px;">

Rules of Recursion

ïµ

Three importantÂ propertiesÂ of a recursiveÂ algorithm:

1\.

TheÂ recursiveÂ algorithmÂ mustÂ haveÂ a base case

2\.

TheÂ recursiveÂ algorithmÂ mustÂ callÂ itselfÂ (called aÂ *recursiveÂ call*)

3\.

TheÂ recursiveÂ callsÂ mustÂ convergeÂ to the baseÂ case

7

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**AlgorithmÂ **factorial(

ğ‘›

):

ğ‘°ğ’ğ’‘ğ’–ğ’•

:Â AnÂ integerÂ 

ğ‘›Â â‰¥Â 0.

ğ‘¶ğ’–ğ’•ğ’‘ğ’–ğ’•

:Â 

ğ‘›\!.

**if**

ğ‘›Â â‰¤Â 1

**then**

**return**

1

**returnÂ **

ğ‘›Â âˆ—

factorial(

ğ‘›Â âˆ’Â 1

)

</div>

<span id="8"></span>

<div id="page8-div" style="position:relative;width:1440px;height:810px;">

RuntimeÂ analysis (recursion)

ïµ

To determineÂ the runtimeÂ of aÂ recursiveÂ solution,Â we need toÂ firstÂ   
determineÂ theÂ recurrence equation

ïµ

WeÂ doÂ this byÂ countingÂ theÂ numberÂ of operations

ïµ

ButÂ nowÂ thereÂ areÂ multipleÂ casesÂ toÂ accountÂ for:Â the baseÂ case,Â andÂ theÂ   
inductiveÂ step

8

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="9"></span>

<div id="page9-div" style="position:relative;width:1440px;height:810px;">

StructureÂ of a recursive algorithm

**AlgorithmÂ **recursiveAlgorithm(

ğ‘›

):

ğ‘°ğ’ğ’‘ğ’–ğ’•

:Â AnÂ integerÂ 

ğ‘›Â â‰¥Â 0.

ğ‘¶ğ’–ğ’•ğ’‘ğ’–ğ’•

:Â AÂ solutionÂ to the problem

**if**

ğ‘›Â =Â 1

**then**

ğ‘ğ‘ğ‘ ğ‘’Â ğ‘ğ‘ğ‘ ğ‘’

**else**

ğ‘–ğ‘›ğ‘‘ğ‘¢ğ‘ğ‘¡ğ‘–ğ‘£ğ‘’Â ğ‘ ğ‘¡ğ‘’ğ‘

recursiveAlgorithm

ğ‘›Â âˆ’Â 1

**end**

9

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

ïµ

Then: Â Â Â  Â T

ğ‘›Â =Â á‰Š

ğ‘

1

,

ğ‘–ğ‘“Â ğ‘›Â =Â 1

ğ‘‡(ğ‘›Â âˆ’Â 1)Â +Â ğ‘

2

,Â otherwise

</div>

<span id="10"></span>

<div id="page10-div" style="position:relative;width:1440px;height:810px;">

Recall: RuntimeÂ analysisÂ ofÂ arrayMax

**AlgorithmÂ **arrayMax(

ğ´,Â ğ‘›

)

ğ‘°ğ’ğ’‘ğ’–ğ’•

:Â AnÂ arrayÂ 

ğ´

storingÂ 

ğ‘›Â â‰¥Â 1

integers

ğ‘¶ğ’–ğ’•ğ’‘ğ’–ğ’•

:Â TheÂ maximumÂ element inÂ 

ğ´

ğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘€ğ‘ğ‘¥Â â†Â ğ´\[0\]

**for**

kÂ â†Â 1

toÂ 

nÂ âˆ’Â 1

**do**

**if**

ğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘€ğ‘ğ‘¥Â \<Â ğ´Â ğ‘˜

**then**

ğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘€ğ‘ğ‘¥Â â†Â ğ´\[ğ‘˜\]

**end**

**end  
returnÂ **

ğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘€ğ‘ğ‘¥

10

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

ğ‘‡(ğ‘›)Â =Â 7ğ‘›Â âˆ’Â 2

</div>

<span id="11"></span>

<div id="page11-div" style="position:relative;width:1440px;height:810px;">

RecursiveÂ arrayMaxÂ example

**AlgorithmÂ **recursiveMax(

ğ´,Â ğ‘›

)

ğ‘°ğ’ğ’‘ğ’–ğ’•

:Â AnÂ arrayÂ 

ğ´

storingÂ 

ğ‘›Â â‰¥Â 1

integers

ğ‘¶ğ’–ğ’•ğ’‘ğ’–ğ’•

:Â TheÂ maximumÂ element inÂ 

ğ´

**if**

ğ‘›Â =Â 1

**then**

**returnÂ **

ğ´\[0\]

**returnÂ **

maxÂ {

recursiveMax(

ğ´,Â ğ‘›Â âˆ’Â 1),Â A\[nÂ âˆ’Â 1\]

}

11

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

**BaseÂ case:Â **3 operationsÂ   
(

ğ‘›Â =Â 1,Â ğ´\[0\]

, return)

**InductionÂ step:Â **

ğ‘‡(ğ‘›Â âˆ’Â 1)Â +Â 7

operations

(ğ‘›Â =Â 1,Â ğ‘›Â âˆ’Â 1,Â ğ‘›Â âˆ’Â 1, call,Â max,Â return)

T

ğ‘›Â =Â á‰Š

ğ‘

1

,

ğ‘–ğ‘“Â ğ‘›Â =Â 1

ğ‘‡(ğ‘›Â âˆ’Â 1)Â +Â ğ‘

2

,Â otherwise

T

ğ‘›Â =Â á‰Š

3,

ğ‘–ğ‘“Â ğ‘›Â =Â 1

ğ‘‡(ğ‘›Â âˆ’Â 1)Â +Â 7,Â otherwise

</div>

<span id="12"></span>

<div id="page12-div" style="position:relative;width:1440px;height:810px;">

RuntimeÂ analysis (recursion)

ïµ

To determineÂ the runtimeÂ of aÂ recursiveÂ solution,Â we need toÂ firstÂ   
determineÂ theÂ recurrence equation

ïµ

WeÂ doÂ this byÂ countingÂ theÂ numberÂ of operations

ïµ

ButÂ nowÂ thereÂ areÂ multipleÂ casesÂ toÂ accountÂ for:Â the baseÂ case,Â andÂ theÂ   
inductiveÂ step

ïµ

We thenÂ need to solveÂ the recurrence equation,Â byÂ expressingÂ theÂ   
equationÂ inÂ **closedÂ form**

ïµ

**closed form**:Â noÂ referencesÂ toÂ the functionÂ *TÂ *appearÂ onÂ theÂ righthandÂ side

12

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

</div>

<span id="13"></span>

<div id="page13-div" style="position:relative;width:1440px;height:810px;">

SolvingÂ recurrenceÂ equationsÂ (recursiveMaxÂ example)

StartingÂ withÂ Â T

ğ‘›Â =Â á‰Š

3,

ğ‘–ğ‘“Â ğ‘›Â =Â 1

ğ‘‡(ğ‘›Â âˆ’Â 1)Â +Â 7,Â otherwise

ïµ

SolvingÂ by repeated substitution:

ğ‘‡Â ğ‘›Â =Â ğ‘‡Â ğ‘›Â âˆ’Â 1Â +Â 7  
ğ‘‡Â ğ‘›Â âˆ’Â 1Â =Â ğ‘‡Â ğ‘›Â âˆ’Â 2Â +Â 7  
ğ‘‡Â ğ‘›Â âˆ’Â 2Â =Â ğ‘‡Â ğ‘›Â âˆ’Â 3Â +Â 7  
â€¦  
ğ‘‡Â 2Â =Â ğ‘‡Â 1Â +Â 7  
ğ‘‡Â 1Â =Â 3

13

CSCÂ 225:Â AlgorithmsÂ andÂ DataÂ StructuresÂ IÂ --Â AnthonyÂ Estey

ğ‘‡Â ğ‘›Â =Â ğ‘‡Â ğ‘›Â âˆ’Â 1Â +Â 7  
ğ‘‡Â ğ‘›Â =Â ğ‘‡Â ğ‘›Â âˆ’Â 2Â +Â 7Â +Â 7Â =Â ğ‘‡Â ğ‘›Â âˆ’Â 2Â +Â 2(7)  
ğ‘‡Â ğ‘›Â =Â ğ‘‡Â ğ‘›Â âˆ’Â 3Â +Â 7Â +Â 2Â 7Â =Â ğ‘‡Â ğ‘›Â âˆ’Â 3Â +Â 3(7)  
â€¦  
ğ‘‡Â ğ‘›Â =Â ğ‘‡Â ğ‘›Â âˆ’Â ğ‘–Â +Â 7ğ‘–  
â€¦  
ğ‘‡Â ğ‘›Â =Â ğ‘‡Â ğ‘›Â âˆ’Â ğ‘›Â âˆ’Â 1

\+Â 7Â ğ‘›Â âˆ’Â 1

ğ‘‡Â ğ‘›Â =Â ğ‘‡Â 1Â +Â 7ğ‘›Â âˆ’Â 7  
ğ‘‡Â ğ‘›Â =Â 3Â +Â 7ğ‘›Â âˆ’Â 7Â =Â 7ğ‘›Â âˆ’Â 4

</div>
