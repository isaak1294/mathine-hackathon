---
{
  "doc_type": "slides",
  "source": "/home/isaak/projects/course-to-md/CSC225/Slides/CSC225Unit3Recursion.pdf",
  "pages": 13,
  "avg_landscape": true,
  "words_est_first2pages": 151,
  "hash": "0935c2e390952510"
}
---

<span id="1"></span>

<div id="page1-div" style="position:relative;width:1440px;height:810px;">

Unit 03:  
Recursion

Anthony Estey

CSC 225: Algorithms and Data Structures I

University of Victoria

\*Thanks to Dr. Rich Little at the University of Victoria for providing some of the contents of these slides

</div>

<span id="2"></span>

<div id="page2-div" style="position:relative;width:1440px;height:810px;">

Unit 03 Overview



Supplemental Reading:



Algorithm Design and Analysis. *Michael Goodrich and Roberto Tamassia*



Pages 10, 19-25



Learning Objectives: (You should be able to…)



understand why we will use pseudocode to support or analysis of algorithms   
and data structures



understand the syntax of pseudocode, and how it maps to operations in a   
programming language like Java, C, or C++



understand the methodology we will use in this course to analyze algorithms   
and data structures, based on the size of the input data, *n*



determine the number of operations required to execute an algorithm through   
an analysis of pseudocode

2

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="3"></span>

<div id="page3-div" style="position:relative;width:1440px;height:810px;">

What is recursion?



A divide-and-conquer approach to solving problems, where the solution   
depends on solutions to smaller instances of the *same *problem



A recursive solution to a problem by using functions/methods that call   
themselves within their own code



Recursion is one of the central ideas of computer science; we will see   
a lot of recursion solutions as we explore different algorithms and data   
structures throughout this course

3

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="4"></span>

<div id="page4-div" style="position:relative;width:1440px;height:810px;">

factorial(

5

)

return 

5 ∗

factorial(

4

)

return 

4 ∗

factorial(

3

)

return 

3 ∗

factorial(

2

)

return 

2 ∗

factorial(

1

)

Example

4

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Algorithm **factorial(

𝑛

):

𝑰𝒏𝒑𝒖𝒕

: An integer 

𝑛 ≥ 0.

𝑶𝒖𝒕𝒑𝒖𝒕

: 

𝑛\!.

**if**

𝑛 ≤ 1

**then**

**return**

1

**return **

𝑛 ∗

factorial(

𝑛 − 1

)

return 

1

</div>

<span id="5"></span>

<div id="page5-div" style="position:relative;width:1440px;height:810px;">

factorial(

5

)

return 

5 ∗

factorial(

4

)

return 

4 ∗

factorial(

3

)

return 

3 ∗

factorial(

2

)

return 

2 ∗

factorial(

1

)

Example

5

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Algorithm **factorial(

𝑛

):

𝑰𝒏𝒑𝒖𝒕

: An integer 

𝑛 ≥ 0.

𝑶𝒖𝒕𝒑𝒖𝒕

: 

𝑛\!.

**if**

𝑛 ≤ 1

**then**

**return**

1

**return **

𝑛 ∗

factorial(

𝑛 − 1

)

24

6

2

1

return 

1

</div>

<span id="6"></span>

<div id="page6-div" style="position:relative;width:1440px;height:810px;">

factorial(

5

)

return 

5 ∗

factorial(

4

)

return 

4 ∗

factorial(

3

)

return 

3 ∗

factorial(

2

)

return 

2 ∗

factorial(

1

)

Example

6

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Algorithm **factorial(

𝑛

):

𝑰𝒏𝒑𝒖𝒕

: An integer 

𝑛 ≥ 0.

𝑶𝒖𝒕𝒑𝒖𝒕

: 

𝑛\!.

**if**

𝑛 ≤ 1

**then**

**return**

1

**return **

𝑛 ∗

factorial(

𝑛 − 1

)

24

6

2

1

return 

1

return 2

return 6

return 24

return 120

</div>

<span id="7"></span>

<div id="page7-div" style="position:relative;width:1440px;height:810px;">

Rules of Recursion



Three important properties of a recursive algorithm:

1\.

The recursive algorithm must have a base case

2\.

The recursive algorithm must call itself (called a *recursive call*)

3\.

The recursive calls must converge to the base case

7

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Algorithm **factorial(

𝑛

):

𝑰𝒏𝒑𝒖𝒕

: An integer 

𝑛 ≥ 0.

𝑶𝒖𝒕𝒑𝒖𝒕

: 

𝑛\!.

**if**

𝑛 ≤ 1

**then**

**return**

1

**return **

𝑛 ∗

factorial(

𝑛 − 1

)

</div>

<span id="8"></span>

<div id="page8-div" style="position:relative;width:1440px;height:810px;">

Runtime analysis (recursion)



To determine the runtime of a recursive solution, we need to first   
determine the recurrence equation



We do this by counting the number of operations



But now there are multiple cases to account for: the base case, and the   
inductive step

8

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="9"></span>

<div id="page9-div" style="position:relative;width:1440px;height:810px;">

Structure of a recursive algorithm

**Algorithm **recursiveAlgorithm(

𝑛

):

𝑰𝒏𝒑𝒖𝒕

: An integer 

𝑛 ≥ 0.

𝑶𝒖𝒕𝒑𝒖𝒕

: A solution to the problem

**if**

𝑛 = 1

**then**

𝑏𝑎𝑠𝑒 𝑐𝑎𝑠𝑒

**else**

𝑖𝑛𝑑𝑢𝑐𝑡𝑖𝑣𝑒 𝑠𝑡𝑒𝑝

recursiveAlgorithm

𝑛 − 1

**end**

9

CSC 225: Algorithms and Data Structures I -- Anthony Estey



Then:      T

𝑛 = ቊ

𝑐

1

,

𝑖𝑓 𝑛 = 1

𝑇(𝑛 − 1) + 𝑐

2

, otherwise

</div>

<span id="10"></span>

<div id="page10-div" style="position:relative;width:1440px;height:810px;">

Recall: Runtime analysis of arrayMax

**Algorithm **arrayMax(

𝐴, 𝑛

)

𝑰𝒏𝒑𝒖𝒕

: An array 

𝐴

storing 

𝑛 ≥ 1

integers

𝑶𝒖𝒕𝒑𝒖𝒕

: The maximum element in 

𝐴

𝑐𝑢𝑟𝑟𝑒𝑛𝑡𝑀𝑎𝑥 ← 𝐴\[0\]

**for**

k ← 1

to 

n − 1

**do**

**if**

𝑐𝑢𝑟𝑟𝑒𝑛𝑡𝑀𝑎𝑥 \< 𝐴 𝑘

**then**

𝑐𝑢𝑟𝑟𝑒𝑛𝑡𝑀𝑎𝑥 ← 𝐴\[𝑘\]

**end**

**end  
return **

𝑐𝑢𝑟𝑟𝑒𝑛𝑡𝑀𝑎𝑥

10

CSC 225: Algorithms and Data Structures I -- Anthony Estey

𝑇(𝑛) = 7𝑛 − 2

</div>

<span id="11"></span>

<div id="page11-div" style="position:relative;width:1440px;height:810px;">

Recursive arrayMax example

**Algorithm **recursiveMax(

𝐴, 𝑛

)

𝑰𝒏𝒑𝒖𝒕

: An array 

𝐴

storing 

𝑛 ≥ 1

integers

𝑶𝒖𝒕𝒑𝒖𝒕

: The maximum element in 

𝐴

**if**

𝑛 = 1

**then**

**return **

𝐴\[0\]

**return **

max {

recursiveMax(

𝐴, 𝑛 − 1), A\[n − 1\]

}

11

CSC 225: Algorithms and Data Structures I -- Anthony Estey

**Base case: **3 operations   
(

𝑛 = 1, 𝐴\[0\]

, return)

**Induction step: **

𝑇(𝑛 − 1) + 7

operations

(𝑛 = 1, 𝑛 − 1, 𝑛 − 1, call, max, return)

T

𝑛 = ቊ

𝑐

1

,

𝑖𝑓 𝑛 = 1

𝑇(𝑛 − 1) + 𝑐

2

, otherwise

T

𝑛 = ቊ

3,

𝑖𝑓 𝑛 = 1

𝑇(𝑛 − 1) + 7, otherwise

</div>

<span id="12"></span>

<div id="page12-div" style="position:relative;width:1440px;height:810px;">

Runtime analysis (recursion)



To determine the runtime of a recursive solution, we need to first   
determine the recurrence equation



We do this by counting the number of operations



But now there are multiple cases to account for: the base case, and the   
inductive step



We then need to solve the recurrence equation, by expressing the   
equation in **closed form**



**closed form**: no references to the function *T *appear on the righthand side

12

CSC 225: Algorithms and Data Structures I -- Anthony Estey

</div>

<span id="13"></span>

<div id="page13-div" style="position:relative;width:1440px;height:810px;">

Solving recurrence equations (recursiveMax example)

Starting with  T

𝑛 = ቊ

3,

𝑖𝑓 𝑛 = 1

𝑇(𝑛 − 1) + 7, otherwise



Solving by repeated substitution:

𝑇 𝑛 = 𝑇 𝑛 − 1 + 7  
𝑇 𝑛 − 1 = 𝑇 𝑛 − 2 + 7  
𝑇 𝑛 − 2 = 𝑇 𝑛 − 3 + 7  
…  
𝑇 2 = 𝑇 1 + 7  
𝑇 1 = 3

13

CSC 225: Algorithms and Data Structures I -- Anthony Estey

𝑇 𝑛 = 𝑇 𝑛 − 1 + 7  
𝑇 𝑛 = 𝑇 𝑛 − 2 + 7 + 7 = 𝑇 𝑛 − 2 + 2(7)  
𝑇 𝑛 = 𝑇 𝑛 − 3 + 7 + 2 7 = 𝑇 𝑛 − 3 + 3(7)  
…  
𝑇 𝑛 = 𝑇 𝑛 − 𝑖 + 7𝑖  
…  
𝑇 𝑛 = 𝑇 𝑛 − 𝑛 − 1

\+ 7 𝑛 − 1

𝑇 𝑛 = 𝑇 1 + 7𝑛 − 7  
𝑇 𝑛 = 3 + 7𝑛 − 7 = 7𝑛 − 4

</div>
